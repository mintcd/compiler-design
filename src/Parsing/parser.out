Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOT

Grammar

Rule 0     S' -> program
Rule 1     program -> declprime
Rule 2     declprime -> decl declprime
Rule 3     declprime -> decl
Rule 4     decl -> vardecl
Rule 5     decl -> funcdecl
Rule 6     vardecl -> idprime CL returnabletype SM
Rule 7     vardecl -> idprime CL returnabletype ASSIGN exprprime SM
Rule 8     funcdecl -> ID CL FUNCTION typ LP paramlist RP INHERIT ID blockstmt
Rule 9     funcdecl -> ID CL FUNCTION typ LP paramlist RP blockstmt
Rule 10    paramdecl -> INHERIT OUT ID CL returnabletype
Rule 11    paramdecl -> OUT ID CL returnabletype
Rule 12    paramdecl -> INHERIT ID CL returnabletype
Rule 13    paramdecl -> ID CL returnabletype
Rule 14    expr -> expr CONCATE expr
Rule 15    expr -> expr LT expr
Rule 16    expr -> expr GT expr
Rule 17    expr -> expr LE expr
Rule 18    expr -> expr GE expr
Rule 19    expr -> expr EQUAL expr
Rule 20    expr -> expr NOT_EQUAL expr
Rule 21    expr -> expr OR expr
Rule 22    expr -> expr AND expr
Rule 23    expr -> expr ADD expr
Rule 24    expr -> expr SUB expr
Rule 25    expr -> expr MUL expr
Rule 26    expr -> expr DIV expr
Rule 27    expr -> expr MOD expr
Rule 28    expr -> NOT expr
Rule 29    expr -> SUB expr
Rule 30    expr -> arraylit
Rule 31    expr -> arraycell
Rule 32    expr -> LP expr RP
Rule 33    expr -> funccall
Rule 34    expr -> INTLIT
Rule 35    expr -> FLOATLIT
Rule 36    expr -> BOOLEANLIT
Rule 37    expr -> STRINGLIT
Rule 38    expr -> ID
Rule 39    arraylit -> LB exprlist RB
Rule 40    arraycell -> ID LSB exprprime RSB
Rule 41    funccall -> ID LP exprlist RP
Rule 42    stmt -> assignstmt
Rule 43    stmt -> ifstmt
Rule 44    stmt -> forstmt
Rule 45    stmt -> whilestmt
Rule 46    stmt -> dowhilestmt
Rule 47    stmt -> breakstmt
Rule 48    stmt -> continuestmt
Rule 49    stmt -> returnstmt
Rule 50    stmt -> callstmt
Rule 51    stmt -> blockstmt
Rule 52    assignstmt -> lhs ASSIGN expr SM
Rule 53    ifstmt -> IF LP expr RP stmt
Rule 54    ifstmt -> IF LP expr RP stmt elsestmt
Rule 55    elsestmt -> ELSE stmt
Rule 56    forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt
Rule 57    whilestmt -> WHILE LP expr RP stmt
Rule 58    dowhilestmt -> DO blockstmt WHILE LP expr RP SM
Rule 59    blockstmt -> LB stmtlist RB
Rule 60    callstmt -> ID LP exprlist RP SM
Rule 61    breakstmt -> BREAK SM
Rule 62    continuestmt -> CONTINUE SM
Rule 63    returnstmt -> RETURN expr SM
Rule 64    returnstmt -> RETURN SM
Rule 65    typ -> returnabletype
Rule 66    typ -> VOID
Rule 67    returnabletype -> array
Rule 68    returnabletype -> atomictype
Rule 69    returnabletype -> AUTO
Rule 70    array -> ARRAY LSB intprime RSB OF atomictype
Rule 71    atomictype -> BOOLEAN
Rule 72    atomictype -> INTEGER
Rule 73    atomictype -> FLOAT
Rule 74    atomictype -> STRING
Rule 75    exprlist -> exprprime
Rule 76    exprlist -> <empty>
Rule 77    exprprime -> expr CM exprprime
Rule 78    exprprime -> expr
Rule 79    paramlist -> paramprime
Rule 80    paramlist -> <empty>
Rule 81    paramprime -> paramdecl CM paramprime
Rule 82    paramprime -> paramdecl
Rule 83    stmtlist -> stmt stmtlist
Rule 84    stmtlist -> vardecl stmtlist
Rule 85    stmtlist -> <empty>
Rule 86    intprime -> INTLIT CM intprime
Rule 87    intprime -> INTLIT
Rule 88    idprime -> ID CM idprime
Rule 89    idprime -> ID
Rule 90    lhs -> ID
Rule 91    lhs -> arraycell

Terminals, with rules where they appear

ADD                  : 23
AND                  : 22
ARRAY                : 70
ASSIGN               : 7 52 56
AUTO                 : 69
BOOLEAN              : 71
BOOLEANLIT           : 36
BREAK                : 61
CL                   : 6 7 8 9 10 11 12 13
CM                   : 56 56 77 81 86 88
CONCATE              : 14
CONTINUE             : 62
DIV                  : 26
DO                   : 58
DOT                  : 
ELSE                 : 55
EQUAL                : 19
FLOAT                : 73
FLOATLIT             : 35
FOR                  : 56
FUNCTION             : 8 9
GE                   : 18
GT                   : 16
ID                   : 8 8 9 10 11 12 13 38 40 41 60 88 89 90
IF                   : 53 54
INHERIT              : 8 10 12
INTEGER              : 72
INTLIT               : 34 86 87
LB                   : 39 59
LE                   : 17
LP                   : 8 9 32 41 53 54 56 57 58 60
LSB                  : 40 70
LT                   : 15
MOD                  : 27
MUL                  : 25
NOT                  : 28
NOT_EQUAL            : 20
OF                   : 70
OR                   : 21
OUT                  : 10 11
RB                   : 39 59
RETURN               : 63 64
RP                   : 8 9 32 41 53 54 56 57 58 60
RSB                  : 40 70
SM                   : 6 7 52 58 60 61 62 63 64
STRING               : 74
STRINGLIT            : 37
SUB                  : 24 29
VOID                 : 66
WHILE                : 57 58
error                : 

Nonterminals, with rules where they appear

array                : 67
arraycell            : 31 91
arraylit             : 30
assignstmt           : 42
atomictype           : 68 70
blockstmt            : 8 9 51 58
breakstmt            : 47
callstmt             : 50
continuestmt         : 48
decl                 : 2 3
declprime            : 1 2
dowhilestmt          : 46
elsestmt             : 54
expr                 : 14 14 15 15 16 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 29 32 52 53 54 56 56 56 57 58 63 77 78
exprlist             : 39 41 60
exprprime            : 7 40 75 77
forstmt              : 44
funccall             : 33
funcdecl             : 5
idprime              : 6 7 88
ifstmt               : 43
intprime             : 70 86
lhs                  : 52 56
paramdecl            : 81 82
paramlist            : 8 9
paramprime           : 79 81
program              : 0
returnabletype       : 6 7 10 11 12 13 65
returnstmt           : 49
stmt                 : 53 54 55 56 57 83
stmtlist             : 59 83 84
typ                  : 8 9
vardecl              : 4 84
whilestmt            : 45

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declprime
    (2) declprime -> . decl declprime
    (3) declprime -> . decl
    (4) decl -> . vardecl
    (5) decl -> . funcdecl
    (6) vardecl -> . idprime CL returnabletype SM
    (7) vardecl -> . idprime CL returnabletype ASSIGN exprprime SM
    (8) funcdecl -> . ID CL FUNCTION typ LP paramlist RP INHERIT ID blockstmt
    (9) funcdecl -> . ID CL FUNCTION typ LP paramlist RP blockstmt
    (88) idprime -> . ID CM idprime
    (89) idprime -> . ID

    ID              shift and go to state 7

    program                        shift and go to state 1
    declprime                      shift and go to state 2
    decl                           shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    idprime                        shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> declprime .

    $end            reduce using rule 1 (program -> declprime .)


state 3

    (2) declprime -> decl . declprime
    (3) declprime -> decl .
    (2) declprime -> . decl declprime
    (3) declprime -> . decl
    (4) decl -> . vardecl
    (5) decl -> . funcdecl
    (6) vardecl -> . idprime CL returnabletype SM
    (7) vardecl -> . idprime CL returnabletype ASSIGN exprprime SM
    (8) funcdecl -> . ID CL FUNCTION typ LP paramlist RP INHERIT ID blockstmt
    (9) funcdecl -> . ID CL FUNCTION typ LP paramlist RP blockstmt
    (88) idprime -> . ID CM idprime
    (89) idprime -> . ID

    $end            reduce using rule 3 (declprime -> decl .)
    ID              shift and go to state 7

    decl                           shift and go to state 3
    declprime                      shift and go to state 8
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    idprime                        shift and go to state 6

state 4

    (4) decl -> vardecl .

    ID              reduce using rule 4 (decl -> vardecl .)
    $end            reduce using rule 4 (decl -> vardecl .)


state 5

    (5) decl -> funcdecl .

    ID              reduce using rule 5 (decl -> funcdecl .)
    $end            reduce using rule 5 (decl -> funcdecl .)


state 6

    (6) vardecl -> idprime . CL returnabletype SM
    (7) vardecl -> idprime . CL returnabletype ASSIGN exprprime SM

    CL              shift and go to state 9


state 7

    (8) funcdecl -> ID . CL FUNCTION typ LP paramlist RP INHERIT ID blockstmt
    (9) funcdecl -> ID . CL FUNCTION typ LP paramlist RP blockstmt
    (88) idprime -> ID . CM idprime
    (89) idprime -> ID .

  ! shift/reduce conflict for CL resolved as shift
    CL              shift and go to state 10
    CM              shift and go to state 11

  ! CL              [ reduce using rule 89 (idprime -> ID .) ]


state 8

    (2) declprime -> decl declprime .

    $end            reduce using rule 2 (declprime -> decl declprime .)


state 9

    (6) vardecl -> idprime CL . returnabletype SM
    (7) vardecl -> idprime CL . returnabletype ASSIGN exprprime SM
    (67) returnabletype -> . array
    (68) returnabletype -> . atomictype
    (69) returnabletype -> . AUTO
    (70) array -> . ARRAY LSB intprime RSB OF atomictype
    (71) atomictype -> . BOOLEAN
    (72) atomictype -> . INTEGER
    (73) atomictype -> . FLOAT
    (74) atomictype -> . STRING

    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    BOOLEAN         shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20

    returnabletype                 shift and go to state 12
    array                          shift and go to state 13
    atomictype                     shift and go to state 14

state 10

    (8) funcdecl -> ID CL . FUNCTION typ LP paramlist RP INHERIT ID blockstmt
    (9) funcdecl -> ID CL . FUNCTION typ LP paramlist RP blockstmt

    FUNCTION        shift and go to state 21


state 11

    (88) idprime -> ID CM . idprime
    (88) idprime -> . ID CM idprime
    (89) idprime -> . ID

    ID              shift and go to state 22

    idprime                        shift and go to state 23

state 12

    (6) vardecl -> idprime CL returnabletype . SM
    (7) vardecl -> idprime CL returnabletype . ASSIGN exprprime SM

    SM              shift and go to state 24
    ASSIGN          shift and go to state 25


state 13

    (67) returnabletype -> array .

    SM              reduce using rule 67 (returnabletype -> array .)
    ASSIGN          reduce using rule 67 (returnabletype -> array .)
    LP              reduce using rule 67 (returnabletype -> array .)
    CM              reduce using rule 67 (returnabletype -> array .)
    RP              reduce using rule 67 (returnabletype -> array .)


state 14

    (68) returnabletype -> atomictype .

    SM              reduce using rule 68 (returnabletype -> atomictype .)
    ASSIGN          reduce using rule 68 (returnabletype -> atomictype .)
    LP              reduce using rule 68 (returnabletype -> atomictype .)
    CM              reduce using rule 68 (returnabletype -> atomictype .)
    RP              reduce using rule 68 (returnabletype -> atomictype .)


state 15

    (69) returnabletype -> AUTO .

    SM              reduce using rule 69 (returnabletype -> AUTO .)
    ASSIGN          reduce using rule 69 (returnabletype -> AUTO .)
    LP              reduce using rule 69 (returnabletype -> AUTO .)
    CM              reduce using rule 69 (returnabletype -> AUTO .)
    RP              reduce using rule 69 (returnabletype -> AUTO .)


state 16

    (70) array -> ARRAY . LSB intprime RSB OF atomictype

    LSB             shift and go to state 26


state 17

    (71) atomictype -> BOOLEAN .

    SM              reduce using rule 71 (atomictype -> BOOLEAN .)
    ASSIGN          reduce using rule 71 (atomictype -> BOOLEAN .)
    LP              reduce using rule 71 (atomictype -> BOOLEAN .)
    CM              reduce using rule 71 (atomictype -> BOOLEAN .)
    RP              reduce using rule 71 (atomictype -> BOOLEAN .)


state 18

    (72) atomictype -> INTEGER .

    SM              reduce using rule 72 (atomictype -> INTEGER .)
    ASSIGN          reduce using rule 72 (atomictype -> INTEGER .)
    LP              reduce using rule 72 (atomictype -> INTEGER .)
    CM              reduce using rule 72 (atomictype -> INTEGER .)
    RP              reduce using rule 72 (atomictype -> INTEGER .)


state 19

    (73) atomictype -> FLOAT .

    SM              reduce using rule 73 (atomictype -> FLOAT .)
    ASSIGN          reduce using rule 73 (atomictype -> FLOAT .)
    LP              reduce using rule 73 (atomictype -> FLOAT .)
    CM              reduce using rule 73 (atomictype -> FLOAT .)
    RP              reduce using rule 73 (atomictype -> FLOAT .)


state 20

    (74) atomictype -> STRING .

    SM              reduce using rule 74 (atomictype -> STRING .)
    ASSIGN          reduce using rule 74 (atomictype -> STRING .)
    LP              reduce using rule 74 (atomictype -> STRING .)
    CM              reduce using rule 74 (atomictype -> STRING .)
    RP              reduce using rule 74 (atomictype -> STRING .)


state 21

    (8) funcdecl -> ID CL FUNCTION . typ LP paramlist RP INHERIT ID blockstmt
    (9) funcdecl -> ID CL FUNCTION . typ LP paramlist RP blockstmt
    (65) typ -> . returnabletype
    (66) typ -> . VOID
    (67) returnabletype -> . array
    (68) returnabletype -> . atomictype
    (69) returnabletype -> . AUTO
    (70) array -> . ARRAY LSB intprime RSB OF atomictype
    (71) atomictype -> . BOOLEAN
    (72) atomictype -> . INTEGER
    (73) atomictype -> . FLOAT
    (74) atomictype -> . STRING

    VOID            shift and go to state 29
    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    BOOLEAN         shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20

    typ                            shift and go to state 27
    returnabletype                 shift and go to state 28
    array                          shift and go to state 13
    atomictype                     shift and go to state 14

state 22

    (88) idprime -> ID . CM idprime
    (89) idprime -> ID .

    CM              shift and go to state 11
    CL              reduce using rule 89 (idprime -> ID .)


state 23

    (88) idprime -> ID CM idprime .

    CL              reduce using rule 88 (idprime -> ID CM idprime .)


state 24

    (6) vardecl -> idprime CL returnabletype SM .

    ID              reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)
    $end            reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)
    IF              reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)
    FOR             reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)
    WHILE           reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)
    DO              reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)
    BREAK           reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)
    CONTINUE        reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)
    RETURN          reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)
    LB              reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)
    RB              reduce using rule 6 (vardecl -> idprime CL returnabletype SM .)


state 25

    (7) vardecl -> idprime CL returnabletype ASSIGN . exprprime SM
    (77) exprprime -> . expr CM exprprime
    (78) exprprime -> . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    exprprime                      shift and go to state 30
    expr                           shift and go to state 31
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 26

    (70) array -> ARRAY LSB . intprime RSB OF atomictype
    (86) intprime -> . INTLIT CM intprime
    (87) intprime -> . INTLIT

    INTLIT          shift and go to state 45

    intprime                       shift and go to state 44

state 27

    (8) funcdecl -> ID CL FUNCTION typ . LP paramlist RP INHERIT ID blockstmt
    (9) funcdecl -> ID CL FUNCTION typ . LP paramlist RP blockstmt

    LP              shift and go to state 46


state 28

    (65) typ -> returnabletype .

    LP              reduce using rule 65 (typ -> returnabletype .)


state 29

    (66) typ -> VOID .

    LP              reduce using rule 66 (typ -> VOID .)


state 30

    (7) vardecl -> idprime CL returnabletype ASSIGN exprprime . SM

    SM              shift and go to state 47


state 31

    (77) exprprime -> expr . CM exprprime
    (78) exprprime -> expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              shift and go to state 48
    SM              reduce using rule 78 (exprprime -> expr .)
    RB              reduce using rule 78 (exprprime -> expr .)
    RSB             reduce using rule 78 (exprprime -> expr .)
    RP              reduce using rule 78 (exprprime -> expr .)
    CONCATE         shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62


state 32

    (29) expr -> SUB . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 63
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 33

    (28) expr -> NOT . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 64
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 34

    (30) expr -> arraylit .

    CM              reduce using rule 30 (expr -> arraylit .)
    CONCATE         reduce using rule 30 (expr -> arraylit .)
    LT              reduce using rule 30 (expr -> arraylit .)
    GT              reduce using rule 30 (expr -> arraylit .)
    LE              reduce using rule 30 (expr -> arraylit .)
    GE              reduce using rule 30 (expr -> arraylit .)
    EQUAL           reduce using rule 30 (expr -> arraylit .)
    NOT_EQUAL       reduce using rule 30 (expr -> arraylit .)
    OR              reduce using rule 30 (expr -> arraylit .)
    AND             reduce using rule 30 (expr -> arraylit .)
    ADD             reduce using rule 30 (expr -> arraylit .)
    SUB             reduce using rule 30 (expr -> arraylit .)
    MUL             reduce using rule 30 (expr -> arraylit .)
    DIV             reduce using rule 30 (expr -> arraylit .)
    MOD             reduce using rule 30 (expr -> arraylit .)
    SM              reduce using rule 30 (expr -> arraylit .)
    RP              reduce using rule 30 (expr -> arraylit .)
    RB              reduce using rule 30 (expr -> arraylit .)
    RSB             reduce using rule 30 (expr -> arraylit .)


state 35

    (31) expr -> arraycell .

    CM              reduce using rule 31 (expr -> arraycell .)
    CONCATE         reduce using rule 31 (expr -> arraycell .)
    LT              reduce using rule 31 (expr -> arraycell .)
    GT              reduce using rule 31 (expr -> arraycell .)
    LE              reduce using rule 31 (expr -> arraycell .)
    GE              reduce using rule 31 (expr -> arraycell .)
    EQUAL           reduce using rule 31 (expr -> arraycell .)
    NOT_EQUAL       reduce using rule 31 (expr -> arraycell .)
    OR              reduce using rule 31 (expr -> arraycell .)
    AND             reduce using rule 31 (expr -> arraycell .)
    ADD             reduce using rule 31 (expr -> arraycell .)
    SUB             reduce using rule 31 (expr -> arraycell .)
    MUL             reduce using rule 31 (expr -> arraycell .)
    DIV             reduce using rule 31 (expr -> arraycell .)
    MOD             reduce using rule 31 (expr -> arraycell .)
    SM              reduce using rule 31 (expr -> arraycell .)
    RP              reduce using rule 31 (expr -> arraycell .)
    RB              reduce using rule 31 (expr -> arraycell .)
    RSB             reduce using rule 31 (expr -> arraycell .)


state 36

    (32) expr -> LP . expr RP
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 65
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 37

    (33) expr -> funccall .

    CM              reduce using rule 33 (expr -> funccall .)
    CONCATE         reduce using rule 33 (expr -> funccall .)
    LT              reduce using rule 33 (expr -> funccall .)
    GT              reduce using rule 33 (expr -> funccall .)
    LE              reduce using rule 33 (expr -> funccall .)
    GE              reduce using rule 33 (expr -> funccall .)
    EQUAL           reduce using rule 33 (expr -> funccall .)
    NOT_EQUAL       reduce using rule 33 (expr -> funccall .)
    OR              reduce using rule 33 (expr -> funccall .)
    AND             reduce using rule 33 (expr -> funccall .)
    ADD             reduce using rule 33 (expr -> funccall .)
    SUB             reduce using rule 33 (expr -> funccall .)
    MUL             reduce using rule 33 (expr -> funccall .)
    DIV             reduce using rule 33 (expr -> funccall .)
    MOD             reduce using rule 33 (expr -> funccall .)
    SM              reduce using rule 33 (expr -> funccall .)
    RP              reduce using rule 33 (expr -> funccall .)
    RB              reduce using rule 33 (expr -> funccall .)
    RSB             reduce using rule 33 (expr -> funccall .)


state 38

    (34) expr -> INTLIT .

    CM              reduce using rule 34 (expr -> INTLIT .)
    CONCATE         reduce using rule 34 (expr -> INTLIT .)
    LT              reduce using rule 34 (expr -> INTLIT .)
    GT              reduce using rule 34 (expr -> INTLIT .)
    LE              reduce using rule 34 (expr -> INTLIT .)
    GE              reduce using rule 34 (expr -> INTLIT .)
    EQUAL           reduce using rule 34 (expr -> INTLIT .)
    NOT_EQUAL       reduce using rule 34 (expr -> INTLIT .)
    OR              reduce using rule 34 (expr -> INTLIT .)
    AND             reduce using rule 34 (expr -> INTLIT .)
    ADD             reduce using rule 34 (expr -> INTLIT .)
    SUB             reduce using rule 34 (expr -> INTLIT .)
    MUL             reduce using rule 34 (expr -> INTLIT .)
    DIV             reduce using rule 34 (expr -> INTLIT .)
    MOD             reduce using rule 34 (expr -> INTLIT .)
    SM              reduce using rule 34 (expr -> INTLIT .)
    RP              reduce using rule 34 (expr -> INTLIT .)
    RB              reduce using rule 34 (expr -> INTLIT .)
    RSB             reduce using rule 34 (expr -> INTLIT .)


state 39

    (35) expr -> FLOATLIT .

    CM              reduce using rule 35 (expr -> FLOATLIT .)
    CONCATE         reduce using rule 35 (expr -> FLOATLIT .)
    LT              reduce using rule 35 (expr -> FLOATLIT .)
    GT              reduce using rule 35 (expr -> FLOATLIT .)
    LE              reduce using rule 35 (expr -> FLOATLIT .)
    GE              reduce using rule 35 (expr -> FLOATLIT .)
    EQUAL           reduce using rule 35 (expr -> FLOATLIT .)
    NOT_EQUAL       reduce using rule 35 (expr -> FLOATLIT .)
    OR              reduce using rule 35 (expr -> FLOATLIT .)
    AND             reduce using rule 35 (expr -> FLOATLIT .)
    ADD             reduce using rule 35 (expr -> FLOATLIT .)
    SUB             reduce using rule 35 (expr -> FLOATLIT .)
    MUL             reduce using rule 35 (expr -> FLOATLIT .)
    DIV             reduce using rule 35 (expr -> FLOATLIT .)
    MOD             reduce using rule 35 (expr -> FLOATLIT .)
    SM              reduce using rule 35 (expr -> FLOATLIT .)
    RP              reduce using rule 35 (expr -> FLOATLIT .)
    RB              reduce using rule 35 (expr -> FLOATLIT .)
    RSB             reduce using rule 35 (expr -> FLOATLIT .)


state 40

    (36) expr -> BOOLEANLIT .

    CM              reduce using rule 36 (expr -> BOOLEANLIT .)
    CONCATE         reduce using rule 36 (expr -> BOOLEANLIT .)
    LT              reduce using rule 36 (expr -> BOOLEANLIT .)
    GT              reduce using rule 36 (expr -> BOOLEANLIT .)
    LE              reduce using rule 36 (expr -> BOOLEANLIT .)
    GE              reduce using rule 36 (expr -> BOOLEANLIT .)
    EQUAL           reduce using rule 36 (expr -> BOOLEANLIT .)
    NOT_EQUAL       reduce using rule 36 (expr -> BOOLEANLIT .)
    OR              reduce using rule 36 (expr -> BOOLEANLIT .)
    AND             reduce using rule 36 (expr -> BOOLEANLIT .)
    ADD             reduce using rule 36 (expr -> BOOLEANLIT .)
    SUB             reduce using rule 36 (expr -> BOOLEANLIT .)
    MUL             reduce using rule 36 (expr -> BOOLEANLIT .)
    DIV             reduce using rule 36 (expr -> BOOLEANLIT .)
    MOD             reduce using rule 36 (expr -> BOOLEANLIT .)
    SM              reduce using rule 36 (expr -> BOOLEANLIT .)
    RP              reduce using rule 36 (expr -> BOOLEANLIT .)
    RB              reduce using rule 36 (expr -> BOOLEANLIT .)
    RSB             reduce using rule 36 (expr -> BOOLEANLIT .)


state 41

    (37) expr -> STRINGLIT .

    CM              reduce using rule 37 (expr -> STRINGLIT .)
    CONCATE         reduce using rule 37 (expr -> STRINGLIT .)
    LT              reduce using rule 37 (expr -> STRINGLIT .)
    GT              reduce using rule 37 (expr -> STRINGLIT .)
    LE              reduce using rule 37 (expr -> STRINGLIT .)
    GE              reduce using rule 37 (expr -> STRINGLIT .)
    EQUAL           reduce using rule 37 (expr -> STRINGLIT .)
    NOT_EQUAL       reduce using rule 37 (expr -> STRINGLIT .)
    OR              reduce using rule 37 (expr -> STRINGLIT .)
    AND             reduce using rule 37 (expr -> STRINGLIT .)
    ADD             reduce using rule 37 (expr -> STRINGLIT .)
    SUB             reduce using rule 37 (expr -> STRINGLIT .)
    MUL             reduce using rule 37 (expr -> STRINGLIT .)
    DIV             reduce using rule 37 (expr -> STRINGLIT .)
    MOD             reduce using rule 37 (expr -> STRINGLIT .)
    SM              reduce using rule 37 (expr -> STRINGLIT .)
    RP              reduce using rule 37 (expr -> STRINGLIT .)
    RB              reduce using rule 37 (expr -> STRINGLIT .)
    RSB             reduce using rule 37 (expr -> STRINGLIT .)


state 42

    (38) expr -> ID .
    (40) arraycell -> ID . LSB exprprime RSB
    (41) funccall -> ID . LP exprlist RP

    CM              reduce using rule 38 (expr -> ID .)
    CONCATE         reduce using rule 38 (expr -> ID .)
    LT              reduce using rule 38 (expr -> ID .)
    GT              reduce using rule 38 (expr -> ID .)
    LE              reduce using rule 38 (expr -> ID .)
    GE              reduce using rule 38 (expr -> ID .)
    EQUAL           reduce using rule 38 (expr -> ID .)
    NOT_EQUAL       reduce using rule 38 (expr -> ID .)
    OR              reduce using rule 38 (expr -> ID .)
    AND             reduce using rule 38 (expr -> ID .)
    ADD             reduce using rule 38 (expr -> ID .)
    SUB             reduce using rule 38 (expr -> ID .)
    MUL             reduce using rule 38 (expr -> ID .)
    DIV             reduce using rule 38 (expr -> ID .)
    MOD             reduce using rule 38 (expr -> ID .)
    SM              reduce using rule 38 (expr -> ID .)
    RP              reduce using rule 38 (expr -> ID .)
    RB              reduce using rule 38 (expr -> ID .)
    RSB             reduce using rule 38 (expr -> ID .)
    LSB             shift and go to state 66
    LP              shift and go to state 67


state 43

    (39) arraylit -> LB . exprlist RB
    (75) exprlist -> . exprprime
    (76) exprlist -> .
    (77) exprprime -> . expr CM exprprime
    (78) exprprime -> . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    RB              reduce using rule 76 (exprlist -> .)
    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    exprlist                       shift and go to state 68
    exprprime                      shift and go to state 69
    expr                           shift and go to state 31
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 44

    (70) array -> ARRAY LSB intprime . RSB OF atomictype

    RSB             shift and go to state 70


state 45

    (86) intprime -> INTLIT . CM intprime
    (87) intprime -> INTLIT .

    CM              shift and go to state 71
    RSB             reduce using rule 87 (intprime -> INTLIT .)


state 46

    (8) funcdecl -> ID CL FUNCTION typ LP . paramlist RP INHERIT ID blockstmt
    (9) funcdecl -> ID CL FUNCTION typ LP . paramlist RP blockstmt
    (79) paramlist -> . paramprime
    (80) paramlist -> .
    (81) paramprime -> . paramdecl CM paramprime
    (82) paramprime -> . paramdecl
    (10) paramdecl -> . INHERIT OUT ID CL returnabletype
    (11) paramdecl -> . OUT ID CL returnabletype
    (12) paramdecl -> . INHERIT ID CL returnabletype
    (13) paramdecl -> . ID CL returnabletype

    RP              reduce using rule 80 (paramlist -> .)
    INHERIT         shift and go to state 74
    OUT             shift and go to state 77
    ID              shift and go to state 72

    paramlist                      shift and go to state 73
    paramprime                     shift and go to state 75
    paramdecl                      shift and go to state 76

state 47

    (7) vardecl -> idprime CL returnabletype ASSIGN exprprime SM .

    ID              reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)
    $end            reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)
    IF              reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)
    FOR             reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)
    WHILE           reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)
    DO              reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)
    BREAK           reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)
    CONTINUE        reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)
    RETURN          reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)
    LB              reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)
    RB              reduce using rule 7 (vardecl -> idprime CL returnabletype ASSIGN exprprime SM .)


state 48

    (77) exprprime -> expr CM . exprprime
    (77) exprprime -> . expr CM exprprime
    (78) exprprime -> . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 31
    exprprime                      shift and go to state 78
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 49

    (14) expr -> expr CONCATE . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 79
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 50

    (15) expr -> expr LT . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 80
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 51

    (16) expr -> expr GT . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 81
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 52

    (17) expr -> expr LE . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 82
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 53

    (18) expr -> expr GE . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 83
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 54

    (19) expr -> expr EQUAL . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 84
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 55

    (20) expr -> expr NOT_EQUAL . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 85
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 56

    (21) expr -> expr OR . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 86
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 57

    (22) expr -> expr AND . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 87
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 58

    (23) expr -> expr ADD . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 88
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 59

    (24) expr -> expr SUB . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 89
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 60

    (25) expr -> expr MUL . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 90
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 61

    (26) expr -> expr DIV . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 91
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 62

    (27) expr -> expr MOD . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 92
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 63

    (29) expr -> SUB expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 29 (expr -> SUB expr .)
    CONCATE         reduce using rule 29 (expr -> SUB expr .)
    LT              reduce using rule 29 (expr -> SUB expr .)
    GT              reduce using rule 29 (expr -> SUB expr .)
    LE              reduce using rule 29 (expr -> SUB expr .)
    GE              reduce using rule 29 (expr -> SUB expr .)
    EQUAL           reduce using rule 29 (expr -> SUB expr .)
    NOT_EQUAL       reduce using rule 29 (expr -> SUB expr .)
    OR              reduce using rule 29 (expr -> SUB expr .)
    AND             reduce using rule 29 (expr -> SUB expr .)
    ADD             reduce using rule 29 (expr -> SUB expr .)
    SUB             reduce using rule 29 (expr -> SUB expr .)
    SM              reduce using rule 29 (expr -> SUB expr .)
    RP              reduce using rule 29 (expr -> SUB expr .)
    RB              reduce using rule 29 (expr -> SUB expr .)
    RSB             reduce using rule 29 (expr -> SUB expr .)
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! MUL             [ reduce using rule 29 (expr -> SUB expr .) ]
  ! DIV             [ reduce using rule 29 (expr -> SUB expr .) ]
  ! MOD             [ reduce using rule 29 (expr -> SUB expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 57 ]
  ! ADD             [ shift and go to state 58 ]
  ! SUB             [ shift and go to state 59 ]


state 64

    (28) expr -> NOT expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 28 (expr -> NOT expr .)
    CONCATE         reduce using rule 28 (expr -> NOT expr .)
    LT              reduce using rule 28 (expr -> NOT expr .)
    GT              reduce using rule 28 (expr -> NOT expr .)
    LE              reduce using rule 28 (expr -> NOT expr .)
    GE              reduce using rule 28 (expr -> NOT expr .)
    EQUAL           reduce using rule 28 (expr -> NOT expr .)
    NOT_EQUAL       reduce using rule 28 (expr -> NOT expr .)
    OR              reduce using rule 28 (expr -> NOT expr .)
    AND             reduce using rule 28 (expr -> NOT expr .)
    ADD             reduce using rule 28 (expr -> NOT expr .)
    SUB             reduce using rule 28 (expr -> NOT expr .)
    MUL             reduce using rule 28 (expr -> NOT expr .)
    DIV             reduce using rule 28 (expr -> NOT expr .)
    MOD             reduce using rule 28 (expr -> NOT expr .)
    SM              reduce using rule 28 (expr -> NOT expr .)
    RP              reduce using rule 28 (expr -> NOT expr .)
    RB              reduce using rule 28 (expr -> NOT expr .)
    RSB             reduce using rule 28 (expr -> NOT expr .)

  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 57 ]
  ! ADD             [ shift and go to state 58 ]
  ! SUB             [ shift and go to state 59 ]
  ! MUL             [ shift and go to state 60 ]
  ! DIV             [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]


state 65

    (32) expr -> LP expr . RP
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    RP              shift and go to state 93
    CONCATE         shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62


state 66

    (40) arraycell -> ID LSB . exprprime RSB
    (77) exprprime -> . expr CM exprprime
    (78) exprprime -> . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    exprprime                      shift and go to state 94
    expr                           shift and go to state 31
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 67

    (41) funccall -> ID LP . exprlist RP
    (75) exprlist -> . exprprime
    (76) exprlist -> .
    (77) exprprime -> . expr CM exprprime
    (78) exprprime -> . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    RP              reduce using rule 76 (exprlist -> .)
    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    exprlist                       shift and go to state 95
    exprprime                      shift and go to state 69
    expr                           shift and go to state 31
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 68

    (39) arraylit -> LB exprlist . RB

    RB              shift and go to state 96


state 69

    (75) exprlist -> exprprime .

    RB              reduce using rule 75 (exprlist -> exprprime .)
    RP              reduce using rule 75 (exprlist -> exprprime .)


state 70

    (70) array -> ARRAY LSB intprime RSB . OF atomictype

    OF              shift and go to state 97


state 71

    (86) intprime -> INTLIT CM . intprime
    (86) intprime -> . INTLIT CM intprime
    (87) intprime -> . INTLIT

    INTLIT          shift and go to state 45

    intprime                       shift and go to state 98

state 72

    (13) paramdecl -> ID . CL returnabletype

    CL              shift and go to state 99


state 73

    (8) funcdecl -> ID CL FUNCTION typ LP paramlist . RP INHERIT ID blockstmt
    (9) funcdecl -> ID CL FUNCTION typ LP paramlist . RP blockstmt

    RP              shift and go to state 100


state 74

    (10) paramdecl -> INHERIT . OUT ID CL returnabletype
    (12) paramdecl -> INHERIT . ID CL returnabletype

    OUT             shift and go to state 101
    ID              shift and go to state 102


state 75

    (79) paramlist -> paramprime .

    RP              reduce using rule 79 (paramlist -> paramprime .)


state 76

    (81) paramprime -> paramdecl . CM paramprime
    (82) paramprime -> paramdecl .

    CM              shift and go to state 103
    RP              reduce using rule 82 (paramprime -> paramdecl .)


state 77

    (11) paramdecl -> OUT . ID CL returnabletype

    ID              shift and go to state 104


state 78

    (77) exprprime -> expr CM exprprime .

    SM              reduce using rule 77 (exprprime -> expr CM exprprime .)
    RB              reduce using rule 77 (exprprime -> expr CM exprprime .)
    RSB             reduce using rule 77 (exprprime -> expr CM exprprime .)
    RP              reduce using rule 77 (exprprime -> expr CM exprprime .)


state 79

    (14) expr -> expr CONCATE expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 14 (expr -> expr CONCATE expr .)
    CONCATE         reduce using rule 14 (expr -> expr CONCATE expr .)
    SM              reduce using rule 14 (expr -> expr CONCATE expr .)
    RP              reduce using rule 14 (expr -> expr CONCATE expr .)
    RB              reduce using rule 14 (expr -> expr CONCATE expr .)
    RSB             reduce using rule 14 (expr -> expr CONCATE expr .)
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! LT              [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! GT              [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! LE              [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! GE              [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! EQUAL           [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! NOT_EQUAL       [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! OR              [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! AND             [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! ADD             [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! SUB             [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! MUL             [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! DIV             [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! MOD             [ reduce using rule 14 (expr -> expr CONCATE expr .) ]
  ! CONCATE         [ shift and go to state 49 ]


state 80

    (15) expr -> expr LT expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 15 (expr -> expr LT expr .)
    CONCATE         reduce using rule 15 (expr -> expr LT expr .)
    LT              reduce using rule 15 (expr -> expr LT expr .)
    GT              reduce using rule 15 (expr -> expr LT expr .)
    LE              reduce using rule 15 (expr -> expr LT expr .)
    GE              reduce using rule 15 (expr -> expr LT expr .)
    EQUAL           reduce using rule 15 (expr -> expr LT expr .)
    NOT_EQUAL       reduce using rule 15 (expr -> expr LT expr .)
    SM              reduce using rule 15 (expr -> expr LT expr .)
    RP              reduce using rule 15 (expr -> expr LT expr .)
    RB              reduce using rule 15 (expr -> expr LT expr .)
    RSB             reduce using rule 15 (expr -> expr LT expr .)
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! OR              [ reduce using rule 15 (expr -> expr LT expr .) ]
  ! AND             [ reduce using rule 15 (expr -> expr LT expr .) ]
  ! ADD             [ reduce using rule 15 (expr -> expr LT expr .) ]
  ! SUB             [ reduce using rule 15 (expr -> expr LT expr .) ]
  ! MUL             [ reduce using rule 15 (expr -> expr LT expr .) ]
  ! DIV             [ reduce using rule 15 (expr -> expr LT expr .) ]
  ! MOD             [ reduce using rule 15 (expr -> expr LT expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 81

    (16) expr -> expr GT expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 16 (expr -> expr GT expr .)
    CONCATE         reduce using rule 16 (expr -> expr GT expr .)
    LT              reduce using rule 16 (expr -> expr GT expr .)
    GT              reduce using rule 16 (expr -> expr GT expr .)
    LE              reduce using rule 16 (expr -> expr GT expr .)
    GE              reduce using rule 16 (expr -> expr GT expr .)
    EQUAL           reduce using rule 16 (expr -> expr GT expr .)
    NOT_EQUAL       reduce using rule 16 (expr -> expr GT expr .)
    SM              reduce using rule 16 (expr -> expr GT expr .)
    RP              reduce using rule 16 (expr -> expr GT expr .)
    RB              reduce using rule 16 (expr -> expr GT expr .)
    RSB             reduce using rule 16 (expr -> expr GT expr .)
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! OR              [ reduce using rule 16 (expr -> expr GT expr .) ]
  ! AND             [ reduce using rule 16 (expr -> expr GT expr .) ]
  ! ADD             [ reduce using rule 16 (expr -> expr GT expr .) ]
  ! SUB             [ reduce using rule 16 (expr -> expr GT expr .) ]
  ! MUL             [ reduce using rule 16 (expr -> expr GT expr .) ]
  ! DIV             [ reduce using rule 16 (expr -> expr GT expr .) ]
  ! MOD             [ reduce using rule 16 (expr -> expr GT expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 82

    (17) expr -> expr LE expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 17 (expr -> expr LE expr .)
    CONCATE         reduce using rule 17 (expr -> expr LE expr .)
    LT              reduce using rule 17 (expr -> expr LE expr .)
    GT              reduce using rule 17 (expr -> expr LE expr .)
    LE              reduce using rule 17 (expr -> expr LE expr .)
    GE              reduce using rule 17 (expr -> expr LE expr .)
    EQUAL           reduce using rule 17 (expr -> expr LE expr .)
    NOT_EQUAL       reduce using rule 17 (expr -> expr LE expr .)
    SM              reduce using rule 17 (expr -> expr LE expr .)
    RP              reduce using rule 17 (expr -> expr LE expr .)
    RB              reduce using rule 17 (expr -> expr LE expr .)
    RSB             reduce using rule 17 (expr -> expr LE expr .)
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! OR              [ reduce using rule 17 (expr -> expr LE expr .) ]
  ! AND             [ reduce using rule 17 (expr -> expr LE expr .) ]
  ! ADD             [ reduce using rule 17 (expr -> expr LE expr .) ]
  ! SUB             [ reduce using rule 17 (expr -> expr LE expr .) ]
  ! MUL             [ reduce using rule 17 (expr -> expr LE expr .) ]
  ! DIV             [ reduce using rule 17 (expr -> expr LE expr .) ]
  ! MOD             [ reduce using rule 17 (expr -> expr LE expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 83

    (18) expr -> expr GE expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 18 (expr -> expr GE expr .)
    CONCATE         reduce using rule 18 (expr -> expr GE expr .)
    LT              reduce using rule 18 (expr -> expr GE expr .)
    GT              reduce using rule 18 (expr -> expr GE expr .)
    LE              reduce using rule 18 (expr -> expr GE expr .)
    GE              reduce using rule 18 (expr -> expr GE expr .)
    EQUAL           reduce using rule 18 (expr -> expr GE expr .)
    NOT_EQUAL       reduce using rule 18 (expr -> expr GE expr .)
    SM              reduce using rule 18 (expr -> expr GE expr .)
    RP              reduce using rule 18 (expr -> expr GE expr .)
    RB              reduce using rule 18 (expr -> expr GE expr .)
    RSB             reduce using rule 18 (expr -> expr GE expr .)
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! OR              [ reduce using rule 18 (expr -> expr GE expr .) ]
  ! AND             [ reduce using rule 18 (expr -> expr GE expr .) ]
  ! ADD             [ reduce using rule 18 (expr -> expr GE expr .) ]
  ! SUB             [ reduce using rule 18 (expr -> expr GE expr .) ]
  ! MUL             [ reduce using rule 18 (expr -> expr GE expr .) ]
  ! DIV             [ reduce using rule 18 (expr -> expr GE expr .) ]
  ! MOD             [ reduce using rule 18 (expr -> expr GE expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 84

    (19) expr -> expr EQUAL expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 19 (expr -> expr EQUAL expr .)
    CONCATE         reduce using rule 19 (expr -> expr EQUAL expr .)
    LT              reduce using rule 19 (expr -> expr EQUAL expr .)
    GT              reduce using rule 19 (expr -> expr EQUAL expr .)
    LE              reduce using rule 19 (expr -> expr EQUAL expr .)
    GE              reduce using rule 19 (expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 19 (expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 19 (expr -> expr EQUAL expr .)
    SM              reduce using rule 19 (expr -> expr EQUAL expr .)
    RP              reduce using rule 19 (expr -> expr EQUAL expr .)
    RB              reduce using rule 19 (expr -> expr EQUAL expr .)
    RSB             reduce using rule 19 (expr -> expr EQUAL expr .)
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! OR              [ reduce using rule 19 (expr -> expr EQUAL expr .) ]
  ! AND             [ reduce using rule 19 (expr -> expr EQUAL expr .) ]
  ! ADD             [ reduce using rule 19 (expr -> expr EQUAL expr .) ]
  ! SUB             [ reduce using rule 19 (expr -> expr EQUAL expr .) ]
  ! MUL             [ reduce using rule 19 (expr -> expr EQUAL expr .) ]
  ! DIV             [ reduce using rule 19 (expr -> expr EQUAL expr .) ]
  ! MOD             [ reduce using rule 19 (expr -> expr EQUAL expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 85

    (20) expr -> expr NOT_EQUAL expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    CONCATE         reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    LT              reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    GT              reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    LE              reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    GE              reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    SM              reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    RP              reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    RB              reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    RSB             reduce using rule 20 (expr -> expr NOT_EQUAL expr .)
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! OR              [ reduce using rule 20 (expr -> expr NOT_EQUAL expr .) ]
  ! AND             [ reduce using rule 20 (expr -> expr NOT_EQUAL expr .) ]
  ! ADD             [ reduce using rule 20 (expr -> expr NOT_EQUAL expr .) ]
  ! SUB             [ reduce using rule 20 (expr -> expr NOT_EQUAL expr .) ]
  ! MUL             [ reduce using rule 20 (expr -> expr NOT_EQUAL expr .) ]
  ! DIV             [ reduce using rule 20 (expr -> expr NOT_EQUAL expr .) ]
  ! MOD             [ reduce using rule 20 (expr -> expr NOT_EQUAL expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]


state 86

    (21) expr -> expr OR expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 21 (expr -> expr OR expr .)
    CONCATE         reduce using rule 21 (expr -> expr OR expr .)
    LT              reduce using rule 21 (expr -> expr OR expr .)
    GT              reduce using rule 21 (expr -> expr OR expr .)
    LE              reduce using rule 21 (expr -> expr OR expr .)
    GE              reduce using rule 21 (expr -> expr OR expr .)
    EQUAL           reduce using rule 21 (expr -> expr OR expr .)
    NOT_EQUAL       reduce using rule 21 (expr -> expr OR expr .)
    OR              reduce using rule 21 (expr -> expr OR expr .)
    AND             reduce using rule 21 (expr -> expr OR expr .)
    SM              reduce using rule 21 (expr -> expr OR expr .)
    RP              reduce using rule 21 (expr -> expr OR expr .)
    RB              reduce using rule 21 (expr -> expr OR expr .)
    RSB             reduce using rule 21 (expr -> expr OR expr .)
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! ADD             [ reduce using rule 21 (expr -> expr OR expr .) ]
  ! SUB             [ reduce using rule 21 (expr -> expr OR expr .) ]
  ! MUL             [ reduce using rule 21 (expr -> expr OR expr .) ]
  ! DIV             [ reduce using rule 21 (expr -> expr OR expr .) ]
  ! MOD             [ reduce using rule 21 (expr -> expr OR expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 57 ]


state 87

    (22) expr -> expr AND expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 22 (expr -> expr AND expr .)
    CONCATE         reduce using rule 22 (expr -> expr AND expr .)
    LT              reduce using rule 22 (expr -> expr AND expr .)
    GT              reduce using rule 22 (expr -> expr AND expr .)
    LE              reduce using rule 22 (expr -> expr AND expr .)
    GE              reduce using rule 22 (expr -> expr AND expr .)
    EQUAL           reduce using rule 22 (expr -> expr AND expr .)
    NOT_EQUAL       reduce using rule 22 (expr -> expr AND expr .)
    OR              reduce using rule 22 (expr -> expr AND expr .)
    AND             reduce using rule 22 (expr -> expr AND expr .)
    SM              reduce using rule 22 (expr -> expr AND expr .)
    RP              reduce using rule 22 (expr -> expr AND expr .)
    RB              reduce using rule 22 (expr -> expr AND expr .)
    RSB             reduce using rule 22 (expr -> expr AND expr .)
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! ADD             [ reduce using rule 22 (expr -> expr AND expr .) ]
  ! SUB             [ reduce using rule 22 (expr -> expr AND expr .) ]
  ! MUL             [ reduce using rule 22 (expr -> expr AND expr .) ]
  ! DIV             [ reduce using rule 22 (expr -> expr AND expr .) ]
  ! MOD             [ reduce using rule 22 (expr -> expr AND expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 57 ]


state 88

    (23) expr -> expr ADD expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 23 (expr -> expr ADD expr .)
    CONCATE         reduce using rule 23 (expr -> expr ADD expr .)
    LT              reduce using rule 23 (expr -> expr ADD expr .)
    GT              reduce using rule 23 (expr -> expr ADD expr .)
    LE              reduce using rule 23 (expr -> expr ADD expr .)
    GE              reduce using rule 23 (expr -> expr ADD expr .)
    EQUAL           reduce using rule 23 (expr -> expr ADD expr .)
    NOT_EQUAL       reduce using rule 23 (expr -> expr ADD expr .)
    OR              reduce using rule 23 (expr -> expr ADD expr .)
    AND             reduce using rule 23 (expr -> expr ADD expr .)
    ADD             reduce using rule 23 (expr -> expr ADD expr .)
    SUB             reduce using rule 23 (expr -> expr ADD expr .)
    SM              reduce using rule 23 (expr -> expr ADD expr .)
    RP              reduce using rule 23 (expr -> expr ADD expr .)
    RB              reduce using rule 23 (expr -> expr ADD expr .)
    RSB             reduce using rule 23 (expr -> expr ADD expr .)
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! MUL             [ reduce using rule 23 (expr -> expr ADD expr .) ]
  ! DIV             [ reduce using rule 23 (expr -> expr ADD expr .) ]
  ! MOD             [ reduce using rule 23 (expr -> expr ADD expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 57 ]
  ! ADD             [ shift and go to state 58 ]
  ! SUB             [ shift and go to state 59 ]


state 89

    (24) expr -> expr SUB expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 24 (expr -> expr SUB expr .)
    CONCATE         reduce using rule 24 (expr -> expr SUB expr .)
    LT              reduce using rule 24 (expr -> expr SUB expr .)
    GT              reduce using rule 24 (expr -> expr SUB expr .)
    LE              reduce using rule 24 (expr -> expr SUB expr .)
    GE              reduce using rule 24 (expr -> expr SUB expr .)
    EQUAL           reduce using rule 24 (expr -> expr SUB expr .)
    NOT_EQUAL       reduce using rule 24 (expr -> expr SUB expr .)
    OR              reduce using rule 24 (expr -> expr SUB expr .)
    AND             reduce using rule 24 (expr -> expr SUB expr .)
    ADD             reduce using rule 24 (expr -> expr SUB expr .)
    SUB             reduce using rule 24 (expr -> expr SUB expr .)
    SM              reduce using rule 24 (expr -> expr SUB expr .)
    RP              reduce using rule 24 (expr -> expr SUB expr .)
    RB              reduce using rule 24 (expr -> expr SUB expr .)
    RSB             reduce using rule 24 (expr -> expr SUB expr .)
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62

  ! MUL             [ reduce using rule 24 (expr -> expr SUB expr .) ]
  ! DIV             [ reduce using rule 24 (expr -> expr SUB expr .) ]
  ! MOD             [ reduce using rule 24 (expr -> expr SUB expr .) ]
  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 57 ]
  ! ADD             [ shift and go to state 58 ]
  ! SUB             [ shift and go to state 59 ]


state 90

    (25) expr -> expr MUL expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 25 (expr -> expr MUL expr .)
    CONCATE         reduce using rule 25 (expr -> expr MUL expr .)
    LT              reduce using rule 25 (expr -> expr MUL expr .)
    GT              reduce using rule 25 (expr -> expr MUL expr .)
    LE              reduce using rule 25 (expr -> expr MUL expr .)
    GE              reduce using rule 25 (expr -> expr MUL expr .)
    EQUAL           reduce using rule 25 (expr -> expr MUL expr .)
    NOT_EQUAL       reduce using rule 25 (expr -> expr MUL expr .)
    OR              reduce using rule 25 (expr -> expr MUL expr .)
    AND             reduce using rule 25 (expr -> expr MUL expr .)
    ADD             reduce using rule 25 (expr -> expr MUL expr .)
    SUB             reduce using rule 25 (expr -> expr MUL expr .)
    MUL             reduce using rule 25 (expr -> expr MUL expr .)
    DIV             reduce using rule 25 (expr -> expr MUL expr .)
    MOD             reduce using rule 25 (expr -> expr MUL expr .)
    SM              reduce using rule 25 (expr -> expr MUL expr .)
    RP              reduce using rule 25 (expr -> expr MUL expr .)
    RB              reduce using rule 25 (expr -> expr MUL expr .)
    RSB             reduce using rule 25 (expr -> expr MUL expr .)

  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 57 ]
  ! ADD             [ shift and go to state 58 ]
  ! SUB             [ shift and go to state 59 ]
  ! MUL             [ shift and go to state 60 ]
  ! DIV             [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]


state 91

    (26) expr -> expr DIV expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 26 (expr -> expr DIV expr .)
    CONCATE         reduce using rule 26 (expr -> expr DIV expr .)
    LT              reduce using rule 26 (expr -> expr DIV expr .)
    GT              reduce using rule 26 (expr -> expr DIV expr .)
    LE              reduce using rule 26 (expr -> expr DIV expr .)
    GE              reduce using rule 26 (expr -> expr DIV expr .)
    EQUAL           reduce using rule 26 (expr -> expr DIV expr .)
    NOT_EQUAL       reduce using rule 26 (expr -> expr DIV expr .)
    OR              reduce using rule 26 (expr -> expr DIV expr .)
    AND             reduce using rule 26 (expr -> expr DIV expr .)
    ADD             reduce using rule 26 (expr -> expr DIV expr .)
    SUB             reduce using rule 26 (expr -> expr DIV expr .)
    MUL             reduce using rule 26 (expr -> expr DIV expr .)
    DIV             reduce using rule 26 (expr -> expr DIV expr .)
    MOD             reduce using rule 26 (expr -> expr DIV expr .)
    SM              reduce using rule 26 (expr -> expr DIV expr .)
    RP              reduce using rule 26 (expr -> expr DIV expr .)
    RB              reduce using rule 26 (expr -> expr DIV expr .)
    RSB             reduce using rule 26 (expr -> expr DIV expr .)

  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 57 ]
  ! ADD             [ shift and go to state 58 ]
  ! SUB             [ shift and go to state 59 ]
  ! MUL             [ shift and go to state 60 ]
  ! DIV             [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]


state 92

    (27) expr -> expr MOD expr .
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              reduce using rule 27 (expr -> expr MOD expr .)
    CONCATE         reduce using rule 27 (expr -> expr MOD expr .)
    LT              reduce using rule 27 (expr -> expr MOD expr .)
    GT              reduce using rule 27 (expr -> expr MOD expr .)
    LE              reduce using rule 27 (expr -> expr MOD expr .)
    GE              reduce using rule 27 (expr -> expr MOD expr .)
    EQUAL           reduce using rule 27 (expr -> expr MOD expr .)
    NOT_EQUAL       reduce using rule 27 (expr -> expr MOD expr .)
    OR              reduce using rule 27 (expr -> expr MOD expr .)
    AND             reduce using rule 27 (expr -> expr MOD expr .)
    ADD             reduce using rule 27 (expr -> expr MOD expr .)
    SUB             reduce using rule 27 (expr -> expr MOD expr .)
    MUL             reduce using rule 27 (expr -> expr MOD expr .)
    DIV             reduce using rule 27 (expr -> expr MOD expr .)
    MOD             reduce using rule 27 (expr -> expr MOD expr .)
    SM              reduce using rule 27 (expr -> expr MOD expr .)
    RP              reduce using rule 27 (expr -> expr MOD expr .)
    RB              reduce using rule 27 (expr -> expr MOD expr .)
    RSB             reduce using rule 27 (expr -> expr MOD expr .)

  ! CONCATE         [ shift and go to state 49 ]
  ! LT              [ shift and go to state 50 ]
  ! GT              [ shift and go to state 51 ]
  ! LE              [ shift and go to state 52 ]
  ! GE              [ shift and go to state 53 ]
  ! EQUAL           [ shift and go to state 54 ]
  ! NOT_EQUAL       [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 57 ]
  ! ADD             [ shift and go to state 58 ]
  ! SUB             [ shift and go to state 59 ]
  ! MUL             [ shift and go to state 60 ]
  ! DIV             [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]


state 93

    (32) expr -> LP expr RP .

    CM              reduce using rule 32 (expr -> LP expr RP .)
    CONCATE         reduce using rule 32 (expr -> LP expr RP .)
    LT              reduce using rule 32 (expr -> LP expr RP .)
    GT              reduce using rule 32 (expr -> LP expr RP .)
    LE              reduce using rule 32 (expr -> LP expr RP .)
    GE              reduce using rule 32 (expr -> LP expr RP .)
    EQUAL           reduce using rule 32 (expr -> LP expr RP .)
    NOT_EQUAL       reduce using rule 32 (expr -> LP expr RP .)
    OR              reduce using rule 32 (expr -> LP expr RP .)
    AND             reduce using rule 32 (expr -> LP expr RP .)
    ADD             reduce using rule 32 (expr -> LP expr RP .)
    SUB             reduce using rule 32 (expr -> LP expr RP .)
    MUL             reduce using rule 32 (expr -> LP expr RP .)
    DIV             reduce using rule 32 (expr -> LP expr RP .)
    MOD             reduce using rule 32 (expr -> LP expr RP .)
    SM              reduce using rule 32 (expr -> LP expr RP .)
    RP              reduce using rule 32 (expr -> LP expr RP .)
    RB              reduce using rule 32 (expr -> LP expr RP .)
    RSB             reduce using rule 32 (expr -> LP expr RP .)


state 94

    (40) arraycell -> ID LSB exprprime . RSB

    RSB             shift and go to state 105


state 95

    (41) funccall -> ID LP exprlist . RP

    RP              shift and go to state 106


state 96

    (39) arraylit -> LB exprlist RB .

    CM              reduce using rule 39 (arraylit -> LB exprlist RB .)
    CONCATE         reduce using rule 39 (arraylit -> LB exprlist RB .)
    LT              reduce using rule 39 (arraylit -> LB exprlist RB .)
    GT              reduce using rule 39 (arraylit -> LB exprlist RB .)
    LE              reduce using rule 39 (arraylit -> LB exprlist RB .)
    GE              reduce using rule 39 (arraylit -> LB exprlist RB .)
    EQUAL           reduce using rule 39 (arraylit -> LB exprlist RB .)
    NOT_EQUAL       reduce using rule 39 (arraylit -> LB exprlist RB .)
    OR              reduce using rule 39 (arraylit -> LB exprlist RB .)
    AND             reduce using rule 39 (arraylit -> LB exprlist RB .)
    ADD             reduce using rule 39 (arraylit -> LB exprlist RB .)
    SUB             reduce using rule 39 (arraylit -> LB exprlist RB .)
    MUL             reduce using rule 39 (arraylit -> LB exprlist RB .)
    DIV             reduce using rule 39 (arraylit -> LB exprlist RB .)
    MOD             reduce using rule 39 (arraylit -> LB exprlist RB .)
    SM              reduce using rule 39 (arraylit -> LB exprlist RB .)
    RP              reduce using rule 39 (arraylit -> LB exprlist RB .)
    RB              reduce using rule 39 (arraylit -> LB exprlist RB .)
    RSB             reduce using rule 39 (arraylit -> LB exprlist RB .)


state 97

    (70) array -> ARRAY LSB intprime RSB OF . atomictype
    (71) atomictype -> . BOOLEAN
    (72) atomictype -> . INTEGER
    (73) atomictype -> . FLOAT
    (74) atomictype -> . STRING

    BOOLEAN         shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20

    atomictype                     shift and go to state 107

state 98

    (86) intprime -> INTLIT CM intprime .

    RSB             reduce using rule 86 (intprime -> INTLIT CM intprime .)


state 99

    (13) paramdecl -> ID CL . returnabletype
    (67) returnabletype -> . array
    (68) returnabletype -> . atomictype
    (69) returnabletype -> . AUTO
    (70) array -> . ARRAY LSB intprime RSB OF atomictype
    (71) atomictype -> . BOOLEAN
    (72) atomictype -> . INTEGER
    (73) atomictype -> . FLOAT
    (74) atomictype -> . STRING

    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    BOOLEAN         shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20

    returnabletype                 shift and go to state 108
    array                          shift and go to state 13
    atomictype                     shift and go to state 14

state 100

    (8) funcdecl -> ID CL FUNCTION typ LP paramlist RP . INHERIT ID blockstmt
    (9) funcdecl -> ID CL FUNCTION typ LP paramlist RP . blockstmt
    (59) blockstmt -> . LB stmtlist RB

    INHERIT         shift and go to state 109
    LB              shift and go to state 111

    blockstmt                      shift and go to state 110

state 101

    (10) paramdecl -> INHERIT OUT . ID CL returnabletype

    ID              shift and go to state 112


state 102

    (12) paramdecl -> INHERIT ID . CL returnabletype

    CL              shift and go to state 113


state 103

    (81) paramprime -> paramdecl CM . paramprime
    (81) paramprime -> . paramdecl CM paramprime
    (82) paramprime -> . paramdecl
    (10) paramdecl -> . INHERIT OUT ID CL returnabletype
    (11) paramdecl -> . OUT ID CL returnabletype
    (12) paramdecl -> . INHERIT ID CL returnabletype
    (13) paramdecl -> . ID CL returnabletype

    INHERIT         shift and go to state 74
    OUT             shift and go to state 77
    ID              shift and go to state 72

    paramdecl                      shift and go to state 76
    paramprime                     shift and go to state 114

state 104

    (11) paramdecl -> OUT ID . CL returnabletype

    CL              shift and go to state 115


state 105

    (40) arraycell -> ID LSB exprprime RSB .

    CM              reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    CONCATE         reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    LT              reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    GT              reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    LE              reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    GE              reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    EQUAL           reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    NOT_EQUAL       reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    OR              reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    AND             reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    ADD             reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    SUB             reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    MUL             reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    DIV             reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    MOD             reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    SM              reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    RP              reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    RB              reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    RSB             reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)
    ASSIGN          reduce using rule 40 (arraycell -> ID LSB exprprime RSB .)


state 106

    (41) funccall -> ID LP exprlist RP .

    CM              reduce using rule 41 (funccall -> ID LP exprlist RP .)
    CONCATE         reduce using rule 41 (funccall -> ID LP exprlist RP .)
    LT              reduce using rule 41 (funccall -> ID LP exprlist RP .)
    GT              reduce using rule 41 (funccall -> ID LP exprlist RP .)
    LE              reduce using rule 41 (funccall -> ID LP exprlist RP .)
    GE              reduce using rule 41 (funccall -> ID LP exprlist RP .)
    EQUAL           reduce using rule 41 (funccall -> ID LP exprlist RP .)
    NOT_EQUAL       reduce using rule 41 (funccall -> ID LP exprlist RP .)
    OR              reduce using rule 41 (funccall -> ID LP exprlist RP .)
    AND             reduce using rule 41 (funccall -> ID LP exprlist RP .)
    ADD             reduce using rule 41 (funccall -> ID LP exprlist RP .)
    SUB             reduce using rule 41 (funccall -> ID LP exprlist RP .)
    MUL             reduce using rule 41 (funccall -> ID LP exprlist RP .)
    DIV             reduce using rule 41 (funccall -> ID LP exprlist RP .)
    MOD             reduce using rule 41 (funccall -> ID LP exprlist RP .)
    SM              reduce using rule 41 (funccall -> ID LP exprlist RP .)
    RP              reduce using rule 41 (funccall -> ID LP exprlist RP .)
    RB              reduce using rule 41 (funccall -> ID LP exprlist RP .)
    RSB             reduce using rule 41 (funccall -> ID LP exprlist RP .)


state 107

    (70) array -> ARRAY LSB intprime RSB OF atomictype .

    SM              reduce using rule 70 (array -> ARRAY LSB intprime RSB OF atomictype .)
    ASSIGN          reduce using rule 70 (array -> ARRAY LSB intprime RSB OF atomictype .)
    LP              reduce using rule 70 (array -> ARRAY LSB intprime RSB OF atomictype .)
    CM              reduce using rule 70 (array -> ARRAY LSB intprime RSB OF atomictype .)
    RP              reduce using rule 70 (array -> ARRAY LSB intprime RSB OF atomictype .)


state 108

    (13) paramdecl -> ID CL returnabletype .

    CM              reduce using rule 13 (paramdecl -> ID CL returnabletype .)
    RP              reduce using rule 13 (paramdecl -> ID CL returnabletype .)


state 109

    (8) funcdecl -> ID CL FUNCTION typ LP paramlist RP INHERIT . ID blockstmt

    ID              shift and go to state 116


state 110

    (9) funcdecl -> ID CL FUNCTION typ LP paramlist RP blockstmt .

    ID              reduce using rule 9 (funcdecl -> ID CL FUNCTION typ LP paramlist RP blockstmt .)
    $end            reduce using rule 9 (funcdecl -> ID CL FUNCTION typ LP paramlist RP blockstmt .)


state 111

    (59) blockstmt -> LB . stmtlist RB
    (83) stmtlist -> . stmt stmtlist
    (84) stmtlist -> . vardecl stmtlist
    (85) stmtlist -> .
    (42) stmt -> . assignstmt
    (43) stmt -> . ifstmt
    (44) stmt -> . forstmt
    (45) stmt -> . whilestmt
    (46) stmt -> . dowhilestmt
    (47) stmt -> . breakstmt
    (48) stmt -> . continuestmt
    (49) stmt -> . returnstmt
    (50) stmt -> . callstmt
    (51) stmt -> . blockstmt
    (6) vardecl -> . idprime CL returnabletype SM
    (7) vardecl -> . idprime CL returnabletype ASSIGN exprprime SM
    (52) assignstmt -> . lhs ASSIGN expr SM
    (53) ifstmt -> . IF LP expr RP stmt
    (54) ifstmt -> . IF LP expr RP stmt elsestmt
    (56) forstmt -> . FOR LP lhs ASSIGN expr CM expr CM expr RP stmt
    (57) whilestmt -> . WHILE LP expr RP stmt
    (58) dowhilestmt -> . DO blockstmt WHILE LP expr RP SM
    (61) breakstmt -> . BREAK SM
    (62) continuestmt -> . CONTINUE SM
    (63) returnstmt -> . RETURN expr SM
    (64) returnstmt -> . RETURN SM
    (60) callstmt -> . ID LP exprlist RP SM
    (59) blockstmt -> . LB stmtlist RB
    (88) idprime -> . ID CM idprime
    (89) idprime -> . ID
    (90) lhs -> . ID
    (91) lhs -> . arraycell
    (40) arraycell -> . ID LSB exprprime RSB

    RB              reduce using rule 85 (stmtlist -> .)
    IF              shift and go to state 131
    FOR             shift and go to state 132
    WHILE           shift and go to state 133
    DO              shift and go to state 134
    BREAK           shift and go to state 135
    CONTINUE        shift and go to state 136
    RETURN          shift and go to state 137
    ID              shift and go to state 138
    LB              shift and go to state 111

    stmtlist                       shift and go to state 117
    stmt                           shift and go to state 118
    vardecl                        shift and go to state 119
    assignstmt                     shift and go to state 120
    ifstmt                         shift and go to state 121
    forstmt                        shift and go to state 122
    whilestmt                      shift and go to state 123
    dowhilestmt                    shift and go to state 124
    breakstmt                      shift and go to state 125
    continuestmt                   shift and go to state 126
    returnstmt                     shift and go to state 127
    callstmt                       shift and go to state 128
    blockstmt                      shift and go to state 129
    idprime                        shift and go to state 6
    lhs                            shift and go to state 130
    arraycell                      shift and go to state 139

state 112

    (10) paramdecl -> INHERIT OUT ID . CL returnabletype

    CL              shift and go to state 140


state 113

    (12) paramdecl -> INHERIT ID CL . returnabletype
    (67) returnabletype -> . array
    (68) returnabletype -> . atomictype
    (69) returnabletype -> . AUTO
    (70) array -> . ARRAY LSB intprime RSB OF atomictype
    (71) atomictype -> . BOOLEAN
    (72) atomictype -> . INTEGER
    (73) atomictype -> . FLOAT
    (74) atomictype -> . STRING

    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    BOOLEAN         shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20

    returnabletype                 shift and go to state 141
    array                          shift and go to state 13
    atomictype                     shift and go to state 14

state 114

    (81) paramprime -> paramdecl CM paramprime .

    RP              reduce using rule 81 (paramprime -> paramdecl CM paramprime .)


state 115

    (11) paramdecl -> OUT ID CL . returnabletype
    (67) returnabletype -> . array
    (68) returnabletype -> . atomictype
    (69) returnabletype -> . AUTO
    (70) array -> . ARRAY LSB intprime RSB OF atomictype
    (71) atomictype -> . BOOLEAN
    (72) atomictype -> . INTEGER
    (73) atomictype -> . FLOAT
    (74) atomictype -> . STRING

    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    BOOLEAN         shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20

    returnabletype                 shift and go to state 142
    array                          shift and go to state 13
    atomictype                     shift and go to state 14

state 116

    (8) funcdecl -> ID CL FUNCTION typ LP paramlist RP INHERIT ID . blockstmt
    (59) blockstmt -> . LB stmtlist RB

    LB              shift and go to state 111

    blockstmt                      shift and go to state 143

state 117

    (59) blockstmt -> LB stmtlist . RB

    RB              shift and go to state 144


state 118

    (83) stmtlist -> stmt . stmtlist
    (83) stmtlist -> . stmt stmtlist
    (84) stmtlist -> . vardecl stmtlist
    (85) stmtlist -> .
    (42) stmt -> . assignstmt
    (43) stmt -> . ifstmt
    (44) stmt -> . forstmt
    (45) stmt -> . whilestmt
    (46) stmt -> . dowhilestmt
    (47) stmt -> . breakstmt
    (48) stmt -> . continuestmt
    (49) stmt -> . returnstmt
    (50) stmt -> . callstmt
    (51) stmt -> . blockstmt
    (6) vardecl -> . idprime CL returnabletype SM
    (7) vardecl -> . idprime CL returnabletype ASSIGN exprprime SM
    (52) assignstmt -> . lhs ASSIGN expr SM
    (53) ifstmt -> . IF LP expr RP stmt
    (54) ifstmt -> . IF LP expr RP stmt elsestmt
    (56) forstmt -> . FOR LP lhs ASSIGN expr CM expr CM expr RP stmt
    (57) whilestmt -> . WHILE LP expr RP stmt
    (58) dowhilestmt -> . DO blockstmt WHILE LP expr RP SM
    (61) breakstmt -> . BREAK SM
    (62) continuestmt -> . CONTINUE SM
    (63) returnstmt -> . RETURN expr SM
    (64) returnstmt -> . RETURN SM
    (60) callstmt -> . ID LP exprlist RP SM
    (59) blockstmt -> . LB stmtlist RB
    (88) idprime -> . ID CM idprime
    (89) idprime -> . ID
    (90) lhs -> . ID
    (91) lhs -> . arraycell
    (40) arraycell -> . ID LSB exprprime RSB

    RB              reduce using rule 85 (stmtlist -> .)
    IF              shift and go to state 131
    FOR             shift and go to state 132
    WHILE           shift and go to state 133
    DO              shift and go to state 134
    BREAK           shift and go to state 135
    CONTINUE        shift and go to state 136
    RETURN          shift and go to state 137
    ID              shift and go to state 138
    LB              shift and go to state 111

    stmt                           shift and go to state 118
    stmtlist                       shift and go to state 145
    vardecl                        shift and go to state 119
    assignstmt                     shift and go to state 120
    ifstmt                         shift and go to state 121
    forstmt                        shift and go to state 122
    whilestmt                      shift and go to state 123
    dowhilestmt                    shift and go to state 124
    breakstmt                      shift and go to state 125
    continuestmt                   shift and go to state 126
    returnstmt                     shift and go to state 127
    callstmt                       shift and go to state 128
    blockstmt                      shift and go to state 129
    idprime                        shift and go to state 6
    lhs                            shift and go to state 130
    arraycell                      shift and go to state 139

state 119

    (84) stmtlist -> vardecl . stmtlist
    (83) stmtlist -> . stmt stmtlist
    (84) stmtlist -> . vardecl stmtlist
    (85) stmtlist -> .
    (42) stmt -> . assignstmt
    (43) stmt -> . ifstmt
    (44) stmt -> . forstmt
    (45) stmt -> . whilestmt
    (46) stmt -> . dowhilestmt
    (47) stmt -> . breakstmt
    (48) stmt -> . continuestmt
    (49) stmt -> . returnstmt
    (50) stmt -> . callstmt
    (51) stmt -> . blockstmt
    (6) vardecl -> . idprime CL returnabletype SM
    (7) vardecl -> . idprime CL returnabletype ASSIGN exprprime SM
    (52) assignstmt -> . lhs ASSIGN expr SM
    (53) ifstmt -> . IF LP expr RP stmt
    (54) ifstmt -> . IF LP expr RP stmt elsestmt
    (56) forstmt -> . FOR LP lhs ASSIGN expr CM expr CM expr RP stmt
    (57) whilestmt -> . WHILE LP expr RP stmt
    (58) dowhilestmt -> . DO blockstmt WHILE LP expr RP SM
    (61) breakstmt -> . BREAK SM
    (62) continuestmt -> . CONTINUE SM
    (63) returnstmt -> . RETURN expr SM
    (64) returnstmt -> . RETURN SM
    (60) callstmt -> . ID LP exprlist RP SM
    (59) blockstmt -> . LB stmtlist RB
    (88) idprime -> . ID CM idprime
    (89) idprime -> . ID
    (90) lhs -> . ID
    (91) lhs -> . arraycell
    (40) arraycell -> . ID LSB exprprime RSB

    RB              reduce using rule 85 (stmtlist -> .)
    IF              shift and go to state 131
    FOR             shift and go to state 132
    WHILE           shift and go to state 133
    DO              shift and go to state 134
    BREAK           shift and go to state 135
    CONTINUE        shift and go to state 136
    RETURN          shift and go to state 137
    ID              shift and go to state 138
    LB              shift and go to state 111

    vardecl                        shift and go to state 119
    stmtlist                       shift and go to state 146
    stmt                           shift and go to state 118
    assignstmt                     shift and go to state 120
    ifstmt                         shift and go to state 121
    forstmt                        shift and go to state 122
    whilestmt                      shift and go to state 123
    dowhilestmt                    shift and go to state 124
    breakstmt                      shift and go to state 125
    continuestmt                   shift and go to state 126
    returnstmt                     shift and go to state 127
    callstmt                       shift and go to state 128
    blockstmt                      shift and go to state 129
    idprime                        shift and go to state 6
    lhs                            shift and go to state 130
    arraycell                      shift and go to state 139

state 120

    (42) stmt -> assignstmt .

    IF              reduce using rule 42 (stmt -> assignstmt .)
    FOR             reduce using rule 42 (stmt -> assignstmt .)
    WHILE           reduce using rule 42 (stmt -> assignstmt .)
    DO              reduce using rule 42 (stmt -> assignstmt .)
    BREAK           reduce using rule 42 (stmt -> assignstmt .)
    CONTINUE        reduce using rule 42 (stmt -> assignstmt .)
    RETURN          reduce using rule 42 (stmt -> assignstmt .)
    ID              reduce using rule 42 (stmt -> assignstmt .)
    LB              reduce using rule 42 (stmt -> assignstmt .)
    RB              reduce using rule 42 (stmt -> assignstmt .)
    ELSE            reduce using rule 42 (stmt -> assignstmt .)


state 121

    (43) stmt -> ifstmt .

    IF              reduce using rule 43 (stmt -> ifstmt .)
    FOR             reduce using rule 43 (stmt -> ifstmt .)
    WHILE           reduce using rule 43 (stmt -> ifstmt .)
    DO              reduce using rule 43 (stmt -> ifstmt .)
    BREAK           reduce using rule 43 (stmt -> ifstmt .)
    CONTINUE        reduce using rule 43 (stmt -> ifstmt .)
    RETURN          reduce using rule 43 (stmt -> ifstmt .)
    ID              reduce using rule 43 (stmt -> ifstmt .)
    LB              reduce using rule 43 (stmt -> ifstmt .)
    RB              reduce using rule 43 (stmt -> ifstmt .)
    ELSE            reduce using rule 43 (stmt -> ifstmt .)


state 122

    (44) stmt -> forstmt .

    IF              reduce using rule 44 (stmt -> forstmt .)
    FOR             reduce using rule 44 (stmt -> forstmt .)
    WHILE           reduce using rule 44 (stmt -> forstmt .)
    DO              reduce using rule 44 (stmt -> forstmt .)
    BREAK           reduce using rule 44 (stmt -> forstmt .)
    CONTINUE        reduce using rule 44 (stmt -> forstmt .)
    RETURN          reduce using rule 44 (stmt -> forstmt .)
    ID              reduce using rule 44 (stmt -> forstmt .)
    LB              reduce using rule 44 (stmt -> forstmt .)
    RB              reduce using rule 44 (stmt -> forstmt .)
    ELSE            reduce using rule 44 (stmt -> forstmt .)


state 123

    (45) stmt -> whilestmt .

    IF              reduce using rule 45 (stmt -> whilestmt .)
    FOR             reduce using rule 45 (stmt -> whilestmt .)
    WHILE           reduce using rule 45 (stmt -> whilestmt .)
    DO              reduce using rule 45 (stmt -> whilestmt .)
    BREAK           reduce using rule 45 (stmt -> whilestmt .)
    CONTINUE        reduce using rule 45 (stmt -> whilestmt .)
    RETURN          reduce using rule 45 (stmt -> whilestmt .)
    ID              reduce using rule 45 (stmt -> whilestmt .)
    LB              reduce using rule 45 (stmt -> whilestmt .)
    RB              reduce using rule 45 (stmt -> whilestmt .)
    ELSE            reduce using rule 45 (stmt -> whilestmt .)


state 124

    (46) stmt -> dowhilestmt .

    IF              reduce using rule 46 (stmt -> dowhilestmt .)
    FOR             reduce using rule 46 (stmt -> dowhilestmt .)
    WHILE           reduce using rule 46 (stmt -> dowhilestmt .)
    DO              reduce using rule 46 (stmt -> dowhilestmt .)
    BREAK           reduce using rule 46 (stmt -> dowhilestmt .)
    CONTINUE        reduce using rule 46 (stmt -> dowhilestmt .)
    RETURN          reduce using rule 46 (stmt -> dowhilestmt .)
    ID              reduce using rule 46 (stmt -> dowhilestmt .)
    LB              reduce using rule 46 (stmt -> dowhilestmt .)
    RB              reduce using rule 46 (stmt -> dowhilestmt .)
    ELSE            reduce using rule 46 (stmt -> dowhilestmt .)


state 125

    (47) stmt -> breakstmt .

    IF              reduce using rule 47 (stmt -> breakstmt .)
    FOR             reduce using rule 47 (stmt -> breakstmt .)
    WHILE           reduce using rule 47 (stmt -> breakstmt .)
    DO              reduce using rule 47 (stmt -> breakstmt .)
    BREAK           reduce using rule 47 (stmt -> breakstmt .)
    CONTINUE        reduce using rule 47 (stmt -> breakstmt .)
    RETURN          reduce using rule 47 (stmt -> breakstmt .)
    ID              reduce using rule 47 (stmt -> breakstmt .)
    LB              reduce using rule 47 (stmt -> breakstmt .)
    RB              reduce using rule 47 (stmt -> breakstmt .)
    ELSE            reduce using rule 47 (stmt -> breakstmt .)


state 126

    (48) stmt -> continuestmt .

    IF              reduce using rule 48 (stmt -> continuestmt .)
    FOR             reduce using rule 48 (stmt -> continuestmt .)
    WHILE           reduce using rule 48 (stmt -> continuestmt .)
    DO              reduce using rule 48 (stmt -> continuestmt .)
    BREAK           reduce using rule 48 (stmt -> continuestmt .)
    CONTINUE        reduce using rule 48 (stmt -> continuestmt .)
    RETURN          reduce using rule 48 (stmt -> continuestmt .)
    ID              reduce using rule 48 (stmt -> continuestmt .)
    LB              reduce using rule 48 (stmt -> continuestmt .)
    RB              reduce using rule 48 (stmt -> continuestmt .)
    ELSE            reduce using rule 48 (stmt -> continuestmt .)


state 127

    (49) stmt -> returnstmt .

    IF              reduce using rule 49 (stmt -> returnstmt .)
    FOR             reduce using rule 49 (stmt -> returnstmt .)
    WHILE           reduce using rule 49 (stmt -> returnstmt .)
    DO              reduce using rule 49 (stmt -> returnstmt .)
    BREAK           reduce using rule 49 (stmt -> returnstmt .)
    CONTINUE        reduce using rule 49 (stmt -> returnstmt .)
    RETURN          reduce using rule 49 (stmt -> returnstmt .)
    ID              reduce using rule 49 (stmt -> returnstmt .)
    LB              reduce using rule 49 (stmt -> returnstmt .)
    RB              reduce using rule 49 (stmt -> returnstmt .)
    ELSE            reduce using rule 49 (stmt -> returnstmt .)


state 128

    (50) stmt -> callstmt .

    IF              reduce using rule 50 (stmt -> callstmt .)
    FOR             reduce using rule 50 (stmt -> callstmt .)
    WHILE           reduce using rule 50 (stmt -> callstmt .)
    DO              reduce using rule 50 (stmt -> callstmt .)
    BREAK           reduce using rule 50 (stmt -> callstmt .)
    CONTINUE        reduce using rule 50 (stmt -> callstmt .)
    RETURN          reduce using rule 50 (stmt -> callstmt .)
    ID              reduce using rule 50 (stmt -> callstmt .)
    LB              reduce using rule 50 (stmt -> callstmt .)
    RB              reduce using rule 50 (stmt -> callstmt .)
    ELSE            reduce using rule 50 (stmt -> callstmt .)


state 129

    (51) stmt -> blockstmt .

    IF              reduce using rule 51 (stmt -> blockstmt .)
    FOR             reduce using rule 51 (stmt -> blockstmt .)
    WHILE           reduce using rule 51 (stmt -> blockstmt .)
    DO              reduce using rule 51 (stmt -> blockstmt .)
    BREAK           reduce using rule 51 (stmt -> blockstmt .)
    CONTINUE        reduce using rule 51 (stmt -> blockstmt .)
    RETURN          reduce using rule 51 (stmt -> blockstmt .)
    ID              reduce using rule 51 (stmt -> blockstmt .)
    LB              reduce using rule 51 (stmt -> blockstmt .)
    RB              reduce using rule 51 (stmt -> blockstmt .)
    ELSE            reduce using rule 51 (stmt -> blockstmt .)


state 130

    (52) assignstmt -> lhs . ASSIGN expr SM

    ASSIGN          shift and go to state 147


state 131

    (53) ifstmt -> IF . LP expr RP stmt
    (54) ifstmt -> IF . LP expr RP stmt elsestmt

    LP              shift and go to state 148


state 132

    (56) forstmt -> FOR . LP lhs ASSIGN expr CM expr CM expr RP stmt

    LP              shift and go to state 149


state 133

    (57) whilestmt -> WHILE . LP expr RP stmt

    LP              shift and go to state 150


state 134

    (58) dowhilestmt -> DO . blockstmt WHILE LP expr RP SM
    (59) blockstmt -> . LB stmtlist RB

    LB              shift and go to state 111

    blockstmt                      shift and go to state 151

state 135

    (61) breakstmt -> BREAK . SM

    SM              shift and go to state 152


state 136

    (62) continuestmt -> CONTINUE . SM

    SM              shift and go to state 153


state 137

    (63) returnstmt -> RETURN . expr SM
    (64) returnstmt -> RETURN . SM
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    SM              shift and go to state 155
    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 154
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 138

    (60) callstmt -> ID . LP exprlist RP SM
    (88) idprime -> ID . CM idprime
    (89) idprime -> ID .
    (90) lhs -> ID .
    (40) arraycell -> ID . LSB exprprime RSB

    LP              shift and go to state 156
    CM              shift and go to state 11
    CL              reduce using rule 89 (idprime -> ID .)
    ASSIGN          reduce using rule 90 (lhs -> ID .)
    LSB             shift and go to state 66


state 139

    (91) lhs -> arraycell .

    ASSIGN          reduce using rule 91 (lhs -> arraycell .)


state 140

    (10) paramdecl -> INHERIT OUT ID CL . returnabletype
    (67) returnabletype -> . array
    (68) returnabletype -> . atomictype
    (69) returnabletype -> . AUTO
    (70) array -> . ARRAY LSB intprime RSB OF atomictype
    (71) atomictype -> . BOOLEAN
    (72) atomictype -> . INTEGER
    (73) atomictype -> . FLOAT
    (74) atomictype -> . STRING

    AUTO            shift and go to state 15
    ARRAY           shift and go to state 16
    BOOLEAN         shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20

    returnabletype                 shift and go to state 157
    array                          shift and go to state 13
    atomictype                     shift and go to state 14

state 141

    (12) paramdecl -> INHERIT ID CL returnabletype .

    CM              reduce using rule 12 (paramdecl -> INHERIT ID CL returnabletype .)
    RP              reduce using rule 12 (paramdecl -> INHERIT ID CL returnabletype .)


state 142

    (11) paramdecl -> OUT ID CL returnabletype .

    CM              reduce using rule 11 (paramdecl -> OUT ID CL returnabletype .)
    RP              reduce using rule 11 (paramdecl -> OUT ID CL returnabletype .)


state 143

    (8) funcdecl -> ID CL FUNCTION typ LP paramlist RP INHERIT ID blockstmt .

    ID              reduce using rule 8 (funcdecl -> ID CL FUNCTION typ LP paramlist RP INHERIT ID blockstmt .)
    $end            reduce using rule 8 (funcdecl -> ID CL FUNCTION typ LP paramlist RP INHERIT ID blockstmt .)


state 144

    (59) blockstmt -> LB stmtlist RB .

    ID              reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    $end            reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    IF              reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    FOR             reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    WHILE           reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    DO              reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    BREAK           reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    CONTINUE        reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    RETURN          reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    LB              reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    RB              reduce using rule 59 (blockstmt -> LB stmtlist RB .)
    ELSE            reduce using rule 59 (blockstmt -> LB stmtlist RB .)


state 145

    (83) stmtlist -> stmt stmtlist .

    RB              reduce using rule 83 (stmtlist -> stmt stmtlist .)


state 146

    (84) stmtlist -> vardecl stmtlist .

    RB              reduce using rule 84 (stmtlist -> vardecl stmtlist .)


state 147

    (52) assignstmt -> lhs ASSIGN . expr SM
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 158
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 148

    (53) ifstmt -> IF LP . expr RP stmt
    (54) ifstmt -> IF LP . expr RP stmt elsestmt
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 159
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 149

    (56) forstmt -> FOR LP . lhs ASSIGN expr CM expr CM expr RP stmt
    (90) lhs -> . ID
    (91) lhs -> . arraycell
    (40) arraycell -> . ID LSB exprprime RSB

    ID              shift and go to state 161

    lhs                            shift and go to state 160
    arraycell                      shift and go to state 139

state 150

    (57) whilestmt -> WHILE LP . expr RP stmt
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 162
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 151

    (58) dowhilestmt -> DO blockstmt . WHILE LP expr RP SM

    WHILE           shift and go to state 163


state 152

    (61) breakstmt -> BREAK SM .

    IF              reduce using rule 61 (breakstmt -> BREAK SM .)
    FOR             reduce using rule 61 (breakstmt -> BREAK SM .)
    WHILE           reduce using rule 61 (breakstmt -> BREAK SM .)
    DO              reduce using rule 61 (breakstmt -> BREAK SM .)
    BREAK           reduce using rule 61 (breakstmt -> BREAK SM .)
    CONTINUE        reduce using rule 61 (breakstmt -> BREAK SM .)
    RETURN          reduce using rule 61 (breakstmt -> BREAK SM .)
    ID              reduce using rule 61 (breakstmt -> BREAK SM .)
    LB              reduce using rule 61 (breakstmt -> BREAK SM .)
    RB              reduce using rule 61 (breakstmt -> BREAK SM .)
    ELSE            reduce using rule 61 (breakstmt -> BREAK SM .)


state 153

    (62) continuestmt -> CONTINUE SM .

    IF              reduce using rule 62 (continuestmt -> CONTINUE SM .)
    FOR             reduce using rule 62 (continuestmt -> CONTINUE SM .)
    WHILE           reduce using rule 62 (continuestmt -> CONTINUE SM .)
    DO              reduce using rule 62 (continuestmt -> CONTINUE SM .)
    BREAK           reduce using rule 62 (continuestmt -> CONTINUE SM .)
    CONTINUE        reduce using rule 62 (continuestmt -> CONTINUE SM .)
    RETURN          reduce using rule 62 (continuestmt -> CONTINUE SM .)
    ID              reduce using rule 62 (continuestmt -> CONTINUE SM .)
    LB              reduce using rule 62 (continuestmt -> CONTINUE SM .)
    RB              reduce using rule 62 (continuestmt -> CONTINUE SM .)
    ELSE            reduce using rule 62 (continuestmt -> CONTINUE SM .)


state 154

    (63) returnstmt -> RETURN expr . SM
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    SM              shift and go to state 164
    CONCATE         shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62


state 155

    (64) returnstmt -> RETURN SM .

    IF              reduce using rule 64 (returnstmt -> RETURN SM .)
    FOR             reduce using rule 64 (returnstmt -> RETURN SM .)
    WHILE           reduce using rule 64 (returnstmt -> RETURN SM .)
    DO              reduce using rule 64 (returnstmt -> RETURN SM .)
    BREAK           reduce using rule 64 (returnstmt -> RETURN SM .)
    CONTINUE        reduce using rule 64 (returnstmt -> RETURN SM .)
    RETURN          reduce using rule 64 (returnstmt -> RETURN SM .)
    ID              reduce using rule 64 (returnstmt -> RETURN SM .)
    LB              reduce using rule 64 (returnstmt -> RETURN SM .)
    RB              reduce using rule 64 (returnstmt -> RETURN SM .)
    ELSE            reduce using rule 64 (returnstmt -> RETURN SM .)


state 156

    (60) callstmt -> ID LP . exprlist RP SM
    (75) exprlist -> . exprprime
    (76) exprlist -> .
    (77) exprprime -> . expr CM exprprime
    (78) exprprime -> . expr
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    RP              reduce using rule 76 (exprlist -> .)
    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    exprlist                       shift and go to state 165
    exprprime                      shift and go to state 69
    expr                           shift and go to state 31
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 157

    (10) paramdecl -> INHERIT OUT ID CL returnabletype .

    CM              reduce using rule 10 (paramdecl -> INHERIT OUT ID CL returnabletype .)
    RP              reduce using rule 10 (paramdecl -> INHERIT OUT ID CL returnabletype .)


state 158

    (52) assignstmt -> lhs ASSIGN expr . SM
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    SM              shift and go to state 166
    CONCATE         shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62


state 159

    (53) ifstmt -> IF LP expr . RP stmt
    (54) ifstmt -> IF LP expr . RP stmt elsestmt
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    RP              shift and go to state 167
    CONCATE         shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62


state 160

    (56) forstmt -> FOR LP lhs . ASSIGN expr CM expr CM expr RP stmt

    ASSIGN          shift and go to state 168


state 161

    (90) lhs -> ID .
    (40) arraycell -> ID . LSB exprprime RSB

    ASSIGN          reduce using rule 90 (lhs -> ID .)
    LSB             shift and go to state 66


state 162

    (57) whilestmt -> WHILE LP expr . RP stmt
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    RP              shift and go to state 169
    CONCATE         shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62


state 163

    (58) dowhilestmt -> DO blockstmt WHILE . LP expr RP SM

    LP              shift and go to state 170


state 164

    (63) returnstmt -> RETURN expr SM .

    IF              reduce using rule 63 (returnstmt -> RETURN expr SM .)
    FOR             reduce using rule 63 (returnstmt -> RETURN expr SM .)
    WHILE           reduce using rule 63 (returnstmt -> RETURN expr SM .)
    DO              reduce using rule 63 (returnstmt -> RETURN expr SM .)
    BREAK           reduce using rule 63 (returnstmt -> RETURN expr SM .)
    CONTINUE        reduce using rule 63 (returnstmt -> RETURN expr SM .)
    RETURN          reduce using rule 63 (returnstmt -> RETURN expr SM .)
    ID              reduce using rule 63 (returnstmt -> RETURN expr SM .)
    LB              reduce using rule 63 (returnstmt -> RETURN expr SM .)
    RB              reduce using rule 63 (returnstmt -> RETURN expr SM .)
    ELSE            reduce using rule 63 (returnstmt -> RETURN expr SM .)


state 165

    (60) callstmt -> ID LP exprlist . RP SM

    RP              shift and go to state 171


state 166

    (52) assignstmt -> lhs ASSIGN expr SM .

    IF              reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)
    FOR             reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)
    WHILE           reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)
    DO              reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)
    BREAK           reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)
    CONTINUE        reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)
    RETURN          reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)
    ID              reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)
    LB              reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)
    RB              reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)
    ELSE            reduce using rule 52 (assignstmt -> lhs ASSIGN expr SM .)


state 167

    (53) ifstmt -> IF LP expr RP . stmt
    (54) ifstmt -> IF LP expr RP . stmt elsestmt
    (42) stmt -> . assignstmt
    (43) stmt -> . ifstmt
    (44) stmt -> . forstmt
    (45) stmt -> . whilestmt
    (46) stmt -> . dowhilestmt
    (47) stmt -> . breakstmt
    (48) stmt -> . continuestmt
    (49) stmt -> . returnstmt
    (50) stmt -> . callstmt
    (51) stmt -> . blockstmt
    (52) assignstmt -> . lhs ASSIGN expr SM
    (53) ifstmt -> . IF LP expr RP stmt
    (54) ifstmt -> . IF LP expr RP stmt elsestmt
    (56) forstmt -> . FOR LP lhs ASSIGN expr CM expr CM expr RP stmt
    (57) whilestmt -> . WHILE LP expr RP stmt
    (58) dowhilestmt -> . DO blockstmt WHILE LP expr RP SM
    (61) breakstmt -> . BREAK SM
    (62) continuestmt -> . CONTINUE SM
    (63) returnstmt -> . RETURN expr SM
    (64) returnstmt -> . RETURN SM
    (60) callstmt -> . ID LP exprlist RP SM
    (59) blockstmt -> . LB stmtlist RB
    (90) lhs -> . ID
    (91) lhs -> . arraycell
    (40) arraycell -> . ID LSB exprprime RSB

    IF              shift and go to state 131
    FOR             shift and go to state 132
    WHILE           shift and go to state 133
    DO              shift and go to state 134
    BREAK           shift and go to state 135
    CONTINUE        shift and go to state 136
    RETURN          shift and go to state 137
    ID              shift and go to state 173
    LB              shift and go to state 111

    stmt                           shift and go to state 172
    assignstmt                     shift and go to state 120
    ifstmt                         shift and go to state 121
    forstmt                        shift and go to state 122
    whilestmt                      shift and go to state 123
    dowhilestmt                    shift and go to state 124
    breakstmt                      shift and go to state 125
    continuestmt                   shift and go to state 126
    returnstmt                     shift and go to state 127
    callstmt                       shift and go to state 128
    blockstmt                      shift and go to state 129
    lhs                            shift and go to state 130
    arraycell                      shift and go to state 139

state 168

    (56) forstmt -> FOR LP lhs ASSIGN . expr CM expr CM expr RP stmt
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 174
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 169

    (57) whilestmt -> WHILE LP expr RP . stmt
    (42) stmt -> . assignstmt
    (43) stmt -> . ifstmt
    (44) stmt -> . forstmt
    (45) stmt -> . whilestmt
    (46) stmt -> . dowhilestmt
    (47) stmt -> . breakstmt
    (48) stmt -> . continuestmt
    (49) stmt -> . returnstmt
    (50) stmt -> . callstmt
    (51) stmt -> . blockstmt
    (52) assignstmt -> . lhs ASSIGN expr SM
    (53) ifstmt -> . IF LP expr RP stmt
    (54) ifstmt -> . IF LP expr RP stmt elsestmt
    (56) forstmt -> . FOR LP lhs ASSIGN expr CM expr CM expr RP stmt
    (57) whilestmt -> . WHILE LP expr RP stmt
    (58) dowhilestmt -> . DO blockstmt WHILE LP expr RP SM
    (61) breakstmt -> . BREAK SM
    (62) continuestmt -> . CONTINUE SM
    (63) returnstmt -> . RETURN expr SM
    (64) returnstmt -> . RETURN SM
    (60) callstmt -> . ID LP exprlist RP SM
    (59) blockstmt -> . LB stmtlist RB
    (90) lhs -> . ID
    (91) lhs -> . arraycell
    (40) arraycell -> . ID LSB exprprime RSB

    IF              shift and go to state 131
    FOR             shift and go to state 132
    WHILE           shift and go to state 133
    DO              shift and go to state 134
    BREAK           shift and go to state 135
    CONTINUE        shift and go to state 136
    RETURN          shift and go to state 137
    ID              shift and go to state 173
    LB              shift and go to state 111

    stmt                           shift and go to state 175
    assignstmt                     shift and go to state 120
    ifstmt                         shift and go to state 121
    forstmt                        shift and go to state 122
    whilestmt                      shift and go to state 123
    dowhilestmt                    shift and go to state 124
    breakstmt                      shift and go to state 125
    continuestmt                   shift and go to state 126
    returnstmt                     shift and go to state 127
    callstmt                       shift and go to state 128
    blockstmt                      shift and go to state 129
    lhs                            shift and go to state 130
    arraycell                      shift and go to state 139

state 170

    (58) dowhilestmt -> DO blockstmt WHILE LP . expr RP SM
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 176
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 171

    (60) callstmt -> ID LP exprlist RP . SM

    SM              shift and go to state 177


state 172

    (53) ifstmt -> IF LP expr RP stmt .
    (54) ifstmt -> IF LP expr RP stmt . elsestmt
    (55) elsestmt -> . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 53 (ifstmt -> IF LP expr RP stmt .)
    FOR             reduce using rule 53 (ifstmt -> IF LP expr RP stmt .)
    WHILE           reduce using rule 53 (ifstmt -> IF LP expr RP stmt .)
    DO              reduce using rule 53 (ifstmt -> IF LP expr RP stmt .)
    BREAK           reduce using rule 53 (ifstmt -> IF LP expr RP stmt .)
    CONTINUE        reduce using rule 53 (ifstmt -> IF LP expr RP stmt .)
    RETURN          reduce using rule 53 (ifstmt -> IF LP expr RP stmt .)
    ID              reduce using rule 53 (ifstmt -> IF LP expr RP stmt .)
    LB              reduce using rule 53 (ifstmt -> IF LP expr RP stmt .)
    RB              reduce using rule 53 (ifstmt -> IF LP expr RP stmt .)
    ELSE            shift and go to state 179

  ! ELSE            [ reduce using rule 53 (ifstmt -> IF LP expr RP stmt .) ]

    elsestmt                       shift and go to state 178

state 173

    (60) callstmt -> ID . LP exprlist RP SM
    (90) lhs -> ID .
    (40) arraycell -> ID . LSB exprprime RSB

    LP              shift and go to state 156
    ASSIGN          reduce using rule 90 (lhs -> ID .)
    LSB             shift and go to state 66


state 174

    (56) forstmt -> FOR LP lhs ASSIGN expr . CM expr CM expr RP stmt
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              shift and go to state 180
    CONCATE         shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62


state 175

    (57) whilestmt -> WHILE LP expr RP stmt .

    IF              reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)
    FOR             reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)
    WHILE           reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)
    DO              reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)
    BREAK           reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)
    CONTINUE        reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)
    RETURN          reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)
    ID              reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)
    LB              reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)
    RB              reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)
    ELSE            reduce using rule 57 (whilestmt -> WHILE LP expr RP stmt .)


state 176

    (58) dowhilestmt -> DO blockstmt WHILE LP expr . RP SM
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    RP              shift and go to state 181
    CONCATE         shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62


state 177

    (60) callstmt -> ID LP exprlist RP SM .

    IF              reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)
    FOR             reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)
    WHILE           reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)
    DO              reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)
    BREAK           reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)
    CONTINUE        reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)
    RETURN          reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)
    ID              reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)
    LB              reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)
    RB              reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)
    ELSE            reduce using rule 60 (callstmt -> ID LP exprlist RP SM .)


state 178

    (54) ifstmt -> IF LP expr RP stmt elsestmt .

    IF              reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)
    FOR             reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)
    WHILE           reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)
    DO              reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)
    BREAK           reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)
    CONTINUE        reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)
    RETURN          reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)
    ID              reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)
    LB              reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)
    RB              reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)
    ELSE            reduce using rule 54 (ifstmt -> IF LP expr RP stmt elsestmt .)


state 179

    (55) elsestmt -> ELSE . stmt
    (42) stmt -> . assignstmt
    (43) stmt -> . ifstmt
    (44) stmt -> . forstmt
    (45) stmt -> . whilestmt
    (46) stmt -> . dowhilestmt
    (47) stmt -> . breakstmt
    (48) stmt -> . continuestmt
    (49) stmt -> . returnstmt
    (50) stmt -> . callstmt
    (51) stmt -> . blockstmt
    (52) assignstmt -> . lhs ASSIGN expr SM
    (53) ifstmt -> . IF LP expr RP stmt
    (54) ifstmt -> . IF LP expr RP stmt elsestmt
    (56) forstmt -> . FOR LP lhs ASSIGN expr CM expr CM expr RP stmt
    (57) whilestmt -> . WHILE LP expr RP stmt
    (58) dowhilestmt -> . DO blockstmt WHILE LP expr RP SM
    (61) breakstmt -> . BREAK SM
    (62) continuestmt -> . CONTINUE SM
    (63) returnstmt -> . RETURN expr SM
    (64) returnstmt -> . RETURN SM
    (60) callstmt -> . ID LP exprlist RP SM
    (59) blockstmt -> . LB stmtlist RB
    (90) lhs -> . ID
    (91) lhs -> . arraycell
    (40) arraycell -> . ID LSB exprprime RSB

    IF              shift and go to state 131
    FOR             shift and go to state 132
    WHILE           shift and go to state 133
    DO              shift and go to state 134
    BREAK           shift and go to state 135
    CONTINUE        shift and go to state 136
    RETURN          shift and go to state 137
    ID              shift and go to state 173
    LB              shift and go to state 111

    stmt                           shift and go to state 182
    assignstmt                     shift and go to state 120
    ifstmt                         shift and go to state 121
    forstmt                        shift and go to state 122
    whilestmt                      shift and go to state 123
    dowhilestmt                    shift and go to state 124
    breakstmt                      shift and go to state 125
    continuestmt                   shift and go to state 126
    returnstmt                     shift and go to state 127
    callstmt                       shift and go to state 128
    blockstmt                      shift and go to state 129
    lhs                            shift and go to state 130
    arraycell                      shift and go to state 139

state 180

    (56) forstmt -> FOR LP lhs ASSIGN expr CM . expr CM expr RP stmt
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 183
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 181

    (58) dowhilestmt -> DO blockstmt WHILE LP expr RP . SM

    SM              shift and go to state 184


state 182

    (55) elsestmt -> ELSE stmt .

    ELSE            reduce using rule 55 (elsestmt -> ELSE stmt .)
    IF              reduce using rule 55 (elsestmt -> ELSE stmt .)
    FOR             reduce using rule 55 (elsestmt -> ELSE stmt .)
    WHILE           reduce using rule 55 (elsestmt -> ELSE stmt .)
    DO              reduce using rule 55 (elsestmt -> ELSE stmt .)
    BREAK           reduce using rule 55 (elsestmt -> ELSE stmt .)
    CONTINUE        reduce using rule 55 (elsestmt -> ELSE stmt .)
    RETURN          reduce using rule 55 (elsestmt -> ELSE stmt .)
    ID              reduce using rule 55 (elsestmt -> ELSE stmt .)
    LB              reduce using rule 55 (elsestmt -> ELSE stmt .)
    RB              reduce using rule 55 (elsestmt -> ELSE stmt .)


state 183

    (56) forstmt -> FOR LP lhs ASSIGN expr CM expr . CM expr RP stmt
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    CM              shift and go to state 185
    CONCATE         shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62


state 184

    (58) dowhilestmt -> DO blockstmt WHILE LP expr RP SM .

    IF              reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)
    FOR             reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)
    WHILE           reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)
    DO              reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)
    BREAK           reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)
    CONTINUE        reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)
    RETURN          reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)
    ID              reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)
    LB              reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)
    RB              reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)
    ELSE            reduce using rule 58 (dowhilestmt -> DO blockstmt WHILE LP expr RP SM .)


state 185

    (56) forstmt -> FOR LP lhs ASSIGN expr CM expr CM . expr RP stmt
    (14) expr -> . expr CONCATE expr
    (15) expr -> . expr LT expr
    (16) expr -> . expr GT expr
    (17) expr -> . expr LE expr
    (18) expr -> . expr GE expr
    (19) expr -> . expr EQUAL expr
    (20) expr -> . expr NOT_EQUAL expr
    (21) expr -> . expr OR expr
    (22) expr -> . expr AND expr
    (23) expr -> . expr ADD expr
    (24) expr -> . expr SUB expr
    (25) expr -> . expr MUL expr
    (26) expr -> . expr DIV expr
    (27) expr -> . expr MOD expr
    (28) expr -> . NOT expr
    (29) expr -> . SUB expr
    (30) expr -> . arraylit
    (31) expr -> . arraycell
    (32) expr -> . LP expr RP
    (33) expr -> . funccall
    (34) expr -> . INTLIT
    (35) expr -> . FLOATLIT
    (36) expr -> . BOOLEANLIT
    (37) expr -> . STRINGLIT
    (38) expr -> . ID
    (39) arraylit -> . LB exprlist RB
    (40) arraycell -> . ID LSB exprprime RSB
    (41) funccall -> . ID LP exprlist RP

    NOT             shift and go to state 33
    SUB             shift and go to state 32
    LP              shift and go to state 36
    INTLIT          shift and go to state 38
    FLOATLIT        shift and go to state 39
    BOOLEANLIT      shift and go to state 40
    STRINGLIT       shift and go to state 41
    ID              shift and go to state 42
    LB              shift and go to state 43

    expr                           shift and go to state 186
    arraylit                       shift and go to state 34
    arraycell                      shift and go to state 35
    funccall                       shift and go to state 37

state 186

    (56) forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr . RP stmt
    (14) expr -> expr . CONCATE expr
    (15) expr -> expr . LT expr
    (16) expr -> expr . GT expr
    (17) expr -> expr . LE expr
    (18) expr -> expr . GE expr
    (19) expr -> expr . EQUAL expr
    (20) expr -> expr . NOT_EQUAL expr
    (21) expr -> expr . OR expr
    (22) expr -> expr . AND expr
    (23) expr -> expr . ADD expr
    (24) expr -> expr . SUB expr
    (25) expr -> expr . MUL expr
    (26) expr -> expr . DIV expr
    (27) expr -> expr . MOD expr

    RP              shift and go to state 187
    CONCATE         shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    EQUAL           shift and go to state 54
    NOT_EQUAL       shift and go to state 55
    OR              shift and go to state 56
    AND             shift and go to state 57
    ADD             shift and go to state 58
    SUB             shift and go to state 59
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 62


state 187

    (56) forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP . stmt
    (42) stmt -> . assignstmt
    (43) stmt -> . ifstmt
    (44) stmt -> . forstmt
    (45) stmt -> . whilestmt
    (46) stmt -> . dowhilestmt
    (47) stmt -> . breakstmt
    (48) stmt -> . continuestmt
    (49) stmt -> . returnstmt
    (50) stmt -> . callstmt
    (51) stmt -> . blockstmt
    (52) assignstmt -> . lhs ASSIGN expr SM
    (53) ifstmt -> . IF LP expr RP stmt
    (54) ifstmt -> . IF LP expr RP stmt elsestmt
    (56) forstmt -> . FOR LP lhs ASSIGN expr CM expr CM expr RP stmt
    (57) whilestmt -> . WHILE LP expr RP stmt
    (58) dowhilestmt -> . DO blockstmt WHILE LP expr RP SM
    (61) breakstmt -> . BREAK SM
    (62) continuestmt -> . CONTINUE SM
    (63) returnstmt -> . RETURN expr SM
    (64) returnstmt -> . RETURN SM
    (60) callstmt -> . ID LP exprlist RP SM
    (59) blockstmt -> . LB stmtlist RB
    (90) lhs -> . ID
    (91) lhs -> . arraycell
    (40) arraycell -> . ID LSB exprprime RSB

    IF              shift and go to state 131
    FOR             shift and go to state 132
    WHILE           shift and go to state 133
    DO              shift and go to state 134
    BREAK           shift and go to state 135
    CONTINUE        shift and go to state 136
    RETURN          shift and go to state 137
    ID              shift and go to state 173
    LB              shift and go to state 111

    lhs                            shift and go to state 130
    stmt                           shift and go to state 188
    assignstmt                     shift and go to state 120
    ifstmt                         shift and go to state 121
    forstmt                        shift and go to state 122
    whilestmt                      shift and go to state 123
    dowhilestmt                    shift and go to state 124
    breakstmt                      shift and go to state 125
    continuestmt                   shift and go to state 126
    returnstmt                     shift and go to state 127
    callstmt                       shift and go to state 128
    blockstmt                      shift and go to state 129
    arraycell                      shift and go to state 139

state 188

    (56) forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .

    IF              reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)
    FOR             reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)
    WHILE           reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)
    DO              reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)
    BREAK           reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)
    CONTINUE        reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)
    RETURN          reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)
    ID              reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)
    LB              reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)
    RB              reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)
    ELSE            reduce using rule 56 (forstmt -> FOR LP lhs ASSIGN expr CM expr CM expr RP stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CL in state 7 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 172 resolved as shift
